local Neox = loadstring(game:HttpGet("https://raw.githubusercontent.com/hassanxzayn-lua/hassanxzayn-lua/main/neoxfluentlib"))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local VirtualInputManager = game:GetService("VirtualInputManager")

local LocalPlayer = Players.LocalPlayer
local KnitServices = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")

local function GetServiceRemote(serviceName, remoteType, remoteName)
    local success, result = pcall(function()
        return KnitServices:WaitForChild(serviceName):WaitForChild("RF"):WaitForChild(remoteName)
    end)
    return success and result or nil
end

local ToolActivated = GetServiceRemote("ToolService", "RF", "ToolActivated")
local ChangeSequence = GetServiceRemote("ForgeService", "RF", "ChangeSequence")
local StartForge = GetServiceRemote("ForgeService", "RF", "StartForge")
local Forge = GetServiceRemote("ProximityService", "RF", "Forge")

local minimizeUI = Enum.KeyCode.LeftControl
local Window = Neox:CreateWindow({
    Title = "NEOX HUB | Forge",
    SubTitle = "by neoxsoftworks",
    TabWidth = 120,
    Size = UDim2.fromOffset(600, 450),
    Acrylic = false,
    Theme = "Darker",
    MinimizeKey = minimizeUI
})

local Tabs = {
    Home = Window:AddTab({ Title = " Home", Icon = "rbxassetid://7733960981" }),
    Main = Window:AddTab({ Title = " Main", Icon = "rbxassetid://7743869612" }),
    Altfarm = Window:AddTab({ Title = " Alt Farm", Icon = "rbxassetid://7743875962" }),
    Sell = Window:AddTab({ Title = " Inventory", Icon = "rbxassetid://7734056747" }),
    Forge = Window:AddTab({ Title = " World", Icon = "rbxassetid://7733955511" }),
    AutoAttack = Window:AddTab({ Title = " Combat", Icon = "rbxassetid://4391741881" }),
    Esp = Window:AddTab({ Title = " Esp", Icon = "rbxassetid://7733774602" }),
    Teleport = Window:AddTab({ Title = " Teleport", Icon = "rbxassetid://7733992789" }),
    Weather = Window:AddTab({ Title = "Environment", Icon = "rbxassetid://7734068495" }),
    Player = Window:AddTab({ Title = " Player", Icon = "rbxassetid://7743875962" }),

}

Window:SelectTab(1)

local ExistingUI = CoreGui:FindFirstChild("NeoxHubMinimizeUI")
if ExistingUI then
    ExistingUI:Destroy()
end

local DragUI = Instance.new("ScreenGui")
DragUI.Name = "NeoxHubMinimizeUI"
DragUI.ResetOnSpawn = false
DragUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
DragUI.Parent = CoreGui

local Button = Instance.new("ImageButton") 
Button.Parent = DragUI
Button.Size = UDim2.new(0, 50, 0, 50)
Button.Position = UDim2.new(0, 10, 1, -80)
Button.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Button.BackgroundTransparency = 0
Button.BorderSizePixel = 0
Button.ClipsDescendants = true
Button.Active = true
Button.ZIndex = 1000
Button.Image = "rbxthumb://type=Asset&id=80622869023191&w=150&h=150"
Button.ImageTransparency = 0

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = Button

local function SimulateKeyPress()
    VirtualInputManager:SendKeyEvent(true, minimizeUI, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, minimizeUI, false, game)
end

local isDragging = false
local dragThreshold = 10

Button.MouseButton1Click:Connect(function()
    if isDragging then return end
    SimulateKeyPress()
end)

local dragging, dragStart, startPos

local function StartDrag(input)
    isDragging = false
    dragging = true
    dragStart = input.Position
    startPos = Button.Position

    input.Changed:Connect(function()
        if input.UserInputState == Enum.UserInputState.End then
            dragging = false
        end
    end)
end

local function OnDrag(input)
    if dragging then
        local delta = (input.Position - dragStart).Magnitude
        if delta > dragThreshold then
            isDragging = true
        end
        Button.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + (input.Position.X - dragStart.X),
            startPos.Y.Scale,
            startPos.Y.Offset + (input.Position.Y - dragStart.Y)
        )
    end
end

Button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StartDrag(input)
    end
end)

Button.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        OnDrag(input)
    end
end)

-- Home Tab
Tabs.Home:AddSection("Executor: " .. (identifyexecutor and identifyexecutor() or "Unknown Executor"))
Tabs.Home:AddSection("-------")

Tabs.Home:AddSection("Server")

Tabs.Home:AddButton({
    Title = "Join our Discord",
    Description = "Click this button to copy the invite link!",
    Callback = function()
        local inviteLink = "https://discord.gg/99UuEwM9sX"
        if setclipboard then
            setclipboard(inviteLink)
        end
    end
})

Tabs.Home:AddParagraph({
    Title = "Report/Suggestion",
    Content = "Join our Discord server to report issues or suggest new features"
})







-- Auto Mine Section

local AutoMineEnabled = false
local MineTargets = {}
local ActiveMiningTarget = nil
local RockTypes = {}
local CurrentTween = nil
local IsTweening = false
local MineDistanceOffset = 4
local MineTweenSpeed = 50
local MineDropdownRef = nil
local MineBelowTarget = false
local NoclipConnection = nil
local SkipOres = {}
local SkipOresEnabled = false
local SkipLogic = "Skip If Any"
local CameraConnection = nil
local OriginalCameraSettings = {}
local CharacterHighlight = nil
local AutoFarmRegionEnabled = false
local SelectedRegions = {}

-- Alt Farm Variables
local AltFarmEnabled = false
local AltFarmMode = "Helper Alt"
local MainAltName = ""
local WhitelistOres = {}
local WhitelistOresEnabled = false
local NotifiedRocks = {}
local ListeningForMainAlt = false
local MainAltCalledPosition = nil
local MainAltCalledOreName = ""
local AltFarmGUI = nil
local AltFarmStatusLabel = nil
local AltFarmOreLabel = nil
local AltFarmDistanceLabel = nil
local AltFarmRockCountLabel = nil
local AltFarmModeLabel = nil
local IsMovingToWhitelistRock = false
local LastNotificationTime = 0
local NotificationCooldown = 2

-- Priority System Variables
local PausedAutoMineTarget = nil
local AutoMineWasPaused = false

-- GUI Dragging Variables
local dragging = false
local dragInput
local dragStart
local startPos

local function GetOreTypes()
    local oreTypes = {}
    local oresFolder = game:GetService("ReplicatedStorage"):FindFirstChild("Assets")
    
    if oresFolder then
        oresFolder = oresFolder:FindFirstChild("Ores")
    end
    
    if oresFolder then
        for _, oreModel in ipairs(oresFolder:GetChildren()) do
            if oreModel:IsA("Model") then
                table.insert(oreTypes, oreModel.Name)
            end
        end
    end
    
    table.sort(oreTypes)
    return oreTypes
end

local function GetRegions()
    local regions = {}
    local seen = {}
    local rocksFolder = Workspace:FindFirstChild("Rocks")
    
    if rocksFolder then
        for _, region in ipairs(rocksFolder:GetChildren()) do
            if region:IsA("Folder") or region:IsA("Model") then
                if not seen[region.Name] then
                    seen[region.Name] = true
                    table.insert(regions, region.Name)
                end
            end
        end
    end
    
    table.sort(regions)
    return regions
end

local function HasWhitelistOre(rockModel)
    if not WhitelistOresEnabled or #WhitelistOres == 0 then
        return false
    end
    
    for _, child in ipairs(rockModel:GetDescendants()) do
        if child:IsA("Model") and child.Name == "Ore" then
            local oreType = child:GetAttribute("Ore")
            if oreType then
                for _, whitelistOre in ipairs(WhitelistOres) do
                    if string.lower(oreType) == string.lower(whitelistOre) then
                        return true, oreType
                    end
                end
            end
        end
    end
    
    return false
end

local function HasSkippedOre(rockModel)
    if not SkipOresEnabled or #SkipOres == 0 then
        return false
    end
    
    local oresFound = {}
    local hasSkippedOre = false
    local totalOres = 0
    
    for _, child in ipairs(rockModel:GetDescendants()) do
        if child:IsA("Model") and child.Name == "Ore" then
            local oreType = child:GetAttribute("Ore")
            if oreType then
                totalOres = totalOres + 1
                oresFound[oreType] = true
                
                for _, skipOre in ipairs(SkipOres) do
                    if string.lower(oreType) == string.lower(skipOre) then
                        hasSkippedOre = true
                        break
                    end
                end
            end
        end
    end
    
    if SkipLogic == "Skip If Any" then
        return hasSkippedOre
    elseif SkipLogic == "Skip If All" then
        if totalOres == 0 then
            return false
        end
        
        local allAreSkipped = true
        for oreType, _ in pairs(oresFound) do
            local isSkipped = false
            for _, skipOre in ipairs(SkipOres) do
                if string.lower(oreType) == string.lower(skipOre) then
                    isSkipped = true
                    break
                end
            end
            
            if not isSkipped then
                allAreSkipped = false
                break
            end
        end
        
        return allAreSkipped
    end
    
    return false
end

local function CreateAltFarmGUI()
    if AltFarmGUI then
        AltFarmGUI:Destroy()
    end
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AltFarmGUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 260, 0, 140)
    mainFrame.Position = UDim2.new(0.5, -130, 0.05, 0)
    mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = true
    mainFrame.Draggable = false
    mainFrame.Parent = screenGui
    
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 6)
    uiCorner.Parent = mainFrame
    
    local uiStroke = Instance.new("UIStroke")
    uiStroke.Color = Color3.fromRGB(50, 50, 60)
    uiStroke.Thickness = 1
    uiStroke.Parent = mainFrame
    
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 38)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = mainFrame
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 6)
    titleCorner.Parent = titleBar
    
    local titleBarCover = Instance.new("Frame")
    titleBarCover.Size = UDim2.new(1, 0, 0, 15)
    titleBarCover.Position = UDim2.new(0, 0, 1, -15)
    titleBarCover.BackgroundColor3 = Color3.fromRGB(30, 30, 38)
    titleBarCover.BorderSizePixel = 0
    titleBarCover.Parent = titleBar
    
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, -40, 1, 0)
    titleLabel.Position = UDim2.new(0, 10, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "ALT FARM"
    titleLabel.TextColor3 = Color3.fromRGB(220, 220, 230)
    titleLabel.TextSize = 12
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Parent = titleBar
    
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 20, 0, 20)
    closeButton.Position = UDim2.new(1, -25, 0, 5)
    closeButton.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    closeButton.BorderSizePixel = 0
    closeButton.Text = "Ã—"
    closeButton.TextColor3 = Color3.fromRGB(200, 200, 210)
    closeButton.TextSize = 16
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Parent = titleBar
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 3)
    closeCorner.Parent = closeButton
    
    closeButton.MouseButton1Click:Connect(function()
        screenGui:Destroy()
        AltFarmGUI = nil
    end)
    
    closeButton.MouseEnter:Connect(function()
        closeButton.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
    end)
    
    closeButton.MouseLeave:Connect(function()
        closeButton.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    end)
    
    -- Make draggable
    local function updateInput(input)
        local delta = input.Position - dragStart
        mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
    
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = mainFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    titleBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            updateInput(input)
        end
    end)
    
    local contentFrame = Instance.new("Frame")
    contentFrame.Name = "ContentFrame"
    contentFrame.Size = UDim2.new(1, -20, 1, -40)
    contentFrame.Position = UDim2.new(0, 10, 0, 35)
    contentFrame.BackgroundTransparency = 1
    contentFrame.Parent = mainFrame
    
    local modeLabel = Instance.new("TextLabel")
    modeLabel.Name = "ModeLabel"
    modeLabel.Size = UDim2.new(1, 0, 0, 16)
    modeLabel.Position = UDim2.new(0, 0, 0, 0)
    modeLabel.BackgroundTransparency = 1
    modeLabel.Text = "MODE: Standby"
    modeLabel.TextColor3 = Color3.fromRGB(140, 140, 150)
    modeLabel.TextSize = 10
    modeLabel.Font = Enum.Font.Gotham
    modeLabel.TextXAlignment = Enum.TextXAlignment.Left
    modeLabel.Parent = contentFrame
    
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Name = "StatusLabel"
    statusLabel.Size = UDim2.new(1, 0, 0, 18)
    statusLabel.Position = UDim2.new(0, 0, 0, 20)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = "STATUS: Waiting for notification"
    statusLabel.TextColor3 = Color3.fromRGB(180, 180, 190)
    statusLabel.TextSize = 11
    statusLabel.Font = Enum.Font.GothamMedium
    statusLabel.TextXAlignment = Enum.TextXAlignment.Left
    statusLabel.Parent = contentFrame
    
    local divider1 = Instance.new("Frame")
    divider1.Size = UDim2.new(1, 0, 0, 1)
    divider1.Position = UDim2.new(0, 0, 0, 42)
    divider1.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    divider1.BorderSizePixel = 0
    divider1.Parent = contentFrame
    
    local oreLabel = Instance.new("TextLabel")
    oreLabel.Name = "OreLabel"
    oreLabel.Size = UDim2.new(1, 0, 0, 16)
    oreLabel.Position = UDim2.new(0, 0, 0, 48)
    oreLabel.BackgroundTransparency = 1
    oreLabel.Text = "TARGET: None"
    oreLabel.TextColor3 = Color3.fromRGB(160, 160, 170)
    oreLabel.TextSize = 10
    oreLabel.Font = Enum.Font.GothamMedium
    oreLabel.TextXAlignment = Enum.TextXAlignment.Left
    oreLabel.Parent = contentFrame
    
    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Name = "DistanceLabel"
    distanceLabel.Size = UDim2.new(1, 0, 0, 16)
    distanceLabel.Position = UDim2.new(0, 0, 0, 66)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Text = "DISTANCE: --"
    distanceLabel.TextColor3 = Color3.fromRGB(160, 160, 170)
    distanceLabel.TextSize = 10
    distanceLabel.Font = Enum.Font.Gotham
    distanceLabel.TextXAlignment = Enum.TextXAlignment.Left
    distanceLabel.Parent = contentFrame
    
    local rockCountLabel = Instance.new("TextLabel")
    rockCountLabel.Name = "RockCountLabel"
    rockCountLabel.Size = UDim2.new(1, 0, 0, 16)
    rockCountLabel.Position = UDim2.new(0, 0, 0, 84)
    rockCountLabel.BackgroundTransparency = 1
    rockCountLabel.Text = "NOTIFIED: 0"
    rockCountLabel.TextColor3 = Color3.fromRGB(140, 140, 150)
    rockCountLabel.TextSize = 9
    rockCountLabel.Font = Enum.Font.Gotham
    rockCountLabel.TextXAlignment = Enum.TextXAlignment.Left
    rockCountLabel.Parent = contentFrame
    
    AltFarmGUI = screenGui
    AltFarmStatusLabel = statusLabel
    AltFarmOreLabel = oreLabel
    AltFarmDistanceLabel = distanceLabel
    AltFarmRockCountLabel = rockCountLabel
    AltFarmModeLabel = modeLabel
end

local function UpdateAltFarmGUI(status, ore, distance, mode, rockCount)
    if not AltFarmGUI then return end
    
    if status and AltFarmStatusLabel then
        AltFarmStatusLabel.Text = "STATUS: " .. status
        if status:find("Mining") or status:find("Moving") then
            AltFarmStatusLabel.TextColor3 = Color3.fromRGB(100, 220, 120)
        elseif status:find("Waiting") or status:find("Paused") then
            AltFarmStatusLabel.TextColor3 = Color3.fromRGB(220, 180, 100)
        else
            AltFarmStatusLabel.TextColor3 = Color3.fromRGB(180, 180, 190)
        end
    end
    
    if ore and AltFarmOreLabel then
        AltFarmOreLabel.Text = "TARGET: " .. ore
        if ore ~= "None" and ore ~= "Searching..." then
            AltFarmOreLabel.TextColor3 = Color3.fromRGB(255, 200, 80)
        else
            AltFarmOreLabel.TextColor3 = Color3.fromRGB(160, 160, 170)
        end
    end
    
    if distance and AltFarmDistanceLabel then
        local distNum = tonumber(distance)
        if distNum then
            AltFarmDistanceLabel.Text = string.format("DISTANCE: %.1f studs", distNum)
            if distNum < 30 then
                AltFarmDistanceLabel.TextColor3 = Color3.fromRGB(100, 220, 120)
            elseif distNum < 100 then
                AltFarmDistanceLabel.TextColor3 = Color3.fromRGB(220, 180, 100)
            else
                AltFarmDistanceLabel.TextColor3 = Color3.fromRGB(220, 100, 100)
            end
        else
            AltFarmDistanceLabel.Text = "DISTANCE: --"
            AltFarmDistanceLabel.TextColor3 = Color3.fromRGB(160, 160, 170)
        end
    end
    
    if mode and AltFarmModeLabel then
        AltFarmModeLabel.Text = "MODE: " .. mode
    end
    
    if rockCount and AltFarmRockCountLabel then
        AltFarmRockCountLabel.Text = "NOTIFIED: " .. rockCount
    end
end

local function NotifyMainAlt(rockPosition, oreName)
    if not AltFarmEnabled or AltFarmMode ~= "Helper Alt" or MainAltName == "" then
        return
    end
    
    local currentTime = tick()
    if currentTime - LastNotificationTime < NotificationCooldown then
        return
    end
    
    local Players = game:GetService("Players")
    local TextChatService = game:GetService("TextChatService")
    
    local message = string.format("WHITELISTROCK:%s,%s,%s:%s", 
        tostring(math.floor(rockPosition.X)),
        tostring(math.floor(rockPosition.Y)),
        tostring(math.floor(rockPosition.Z)),
        oreName or "Unknown")
    
    local messageSent = false
    
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        local success, err = pcall(function()
            local generalChannel = TextChatService:WaitForChild("TextChannels"):WaitForChild("RBXGeneral", 5)
            if generalChannel then
                generalChannel:SendAsync(message)
                messageSent = true
            end
        end)
        
        if success and messageSent then
            LastNotificationTime = currentTime
            Fluent:Notify({
                Title = "Alt Farm - Helper",
                Content = "Notified " .. MainAltName .. " about " .. (oreName or "ore") .. "!",
                Duration = 3
            })
        end
    else
        local success, err = pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local SayMessageRequest = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
            if SayMessageRequest then
                SayMessageRequest = SayMessageRequest:FindFirstChild("SayMessageRequest")
                if SayMessageRequest then
                    SayMessageRequest:FireServer(message, "All")
                    messageSent = true
                end
            end
        end)
        
        if success and messageSent then
            LastNotificationTime = currentTime
            Fluent:Notify({
                Title = "Alt Farm - Helper",
                Content = "Notified " .. MainAltName .. " about " .. (oreName or "ore") .. "!",
                Duration = 3
            })
        end
    end
end

local function SetupCharacterHighlight(enabled)
    if CharacterHighlight then
        CharacterHighlight:Destroy()
        CharacterHighlight = nil
    end
    
    if enabled then
        local char = LocalPlayer.Character
        if char then
            CharacterHighlight = Instance.new("Highlight")
            CharacterHighlight.Name = "MiningHighlight"
            CharacterHighlight.FillColor = Color3.fromRGB(255, 0, 0)
            CharacterHighlight.OutlineColor = Color3.fromRGB(255, 100, 100)
            CharacterHighlight.FillTransparency = 0.5
            CharacterHighlight.OutlineTransparency = 0
            CharacterHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            CharacterHighlight.Parent = char
        end
    end
end

local function SetupCamera(enabled)
    local camera = workspace.CurrentCamera
    
    if CameraConnection then
        CameraConnection:Disconnect()
        CameraConnection = nil
    end
    
    if enabled then
        OriginalCameraSettings = {
            CameraType = camera.CameraType,
            CameraSubject = camera.CameraSubject
        }
        
        camera.CameraType = Enum.CameraType.Custom
        
        CameraConnection = game:GetService("RunService").RenderStepped:Connect(function()
            local char = LocalPlayer.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local humanoid = char and char:FindFirstChild("Humanoid")
            
            if char and root and humanoid then
                if MineBelowTarget and ActiveMiningTarget and ActiveMiningTarget.Parent then
                    local targetPos = ActiveMiningTarget.Position
                    local cameraHeight = 15
                    local cameraOffset = Vector3.new(0, cameraHeight, 10)
                    local desiredCameraPos = targetPos + cameraOffset
                    local lookAtPos = targetPos + Vector3.new(0, 2, 0)
                    
                    local raycastParams = RaycastParams.new()
                    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                    raycastParams.FilterDescendantsInstances = {char, workspace.Rocks}
                    
                    local rayResult = workspace:Raycast(targetPos, (desiredCameraPos - targetPos).Unit * cameraHeight, raycastParams)
                    
                    local finalCameraPos = desiredCameraPos
                    
                    if rayResult then
                        local alternativeOffsets = {
                            Vector3.new(0, cameraHeight, -10),
                            Vector3.new(10, cameraHeight, 0),
                            Vector3.new(-10, cameraHeight, 0),
                            Vector3.new(7, cameraHeight, 7),
                            Vector3.new(-7, cameraHeight, 7),
                            Vector3.new(7, cameraHeight, -7),
                            Vector3.new(-7, cameraHeight, -7),
                            Vector3.new(0, cameraHeight + 5, 0)
                        }
                        
                        for _, offset in ipairs(alternativeOffsets) do
                            local testPos = targetPos + offset
                            local testRay = workspace:Raycast(targetPos, (testPos - targetPos).Unit * offset.Magnitude, raycastParams)
                            
                            if not testRay then
                                finalCameraPos = testPos
                                break
                            end
                        end
                    end
                    
                    camera.CFrame = CFrame.new(finalCameraPos, lookAtPos)
                else
                    if camera.CameraSubject ~= humanoid then
                        camera.CameraSubject = humanoid
                    end
                    
                    local targetCFrame = camera.CFrame
                    local targetPos = targetCFrame.Position
                    local rootPos = root.Position
                    
                    local rayDirection = (targetPos - rootPos)
                    local rayLength = rayDirection.Magnitude
                    
                    if rayLength > 0 then
                        local raycastParams = RaycastParams.new()
                        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                        raycastParams.FilterDescendantsInstances = {char, workspace.Rocks}
                        
                        local rayResult = workspace:Raycast(rootPos, rayDirection.Unit * rayLength, raycastParams)
                        
                        if rayResult then
                            local safeDistance = (rayResult.Position - rootPos).Magnitude - 0.5
                            if safeDistance < rayLength then
                                local newPos = rootPos + rayDirection.Unit * math.max(safeDistance, 0.5)
                                camera.CFrame = CFrame.new(newPos, rootPos)
                            end
                        end
                    end
                    
                    if targetPos.Y < rootPos.Y - 2 then
                        local correctedPos = Vector3.new(targetPos.X, rootPos.Y - 2, targetPos.Z)
                        camera.CFrame = CFrame.new(correctedPos, rootPos)
                    end
                end
                
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.LocalTransparencyModifier = 0
                    end
                end
            end
        end)
    else
        if OriginalCameraSettings.CameraType then
            camera.CameraType = OriginalCameraSettings.CameraType
        end
        if OriginalCameraSettings.CameraSubject then
            camera.CameraSubject = OriginalCameraSettings.CameraSubject
        end
        
        local char = LocalPlayer.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.LocalTransparencyModifier = 0
                end
            end
        end
    end
end

local function SetNoclip(enabled)
    if NoclipConnection then
        NoclipConnection:Disconnect()
        NoclipConnection = nil
    end
    
    if enabled then
        local char = LocalPlayer.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
        
        NoclipConnection = game:GetService("RunService").Stepped:Connect(function()
            local character = LocalPlayer.Character
            if character then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        local char = LocalPlayer.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.CanCollide = true
                end
            end
        end
    end
end

local function GetRockTypes()
    local rockTypes = {}
    local seen = {}
    local rocksFolder = Workspace:FindFirstChild("Rocks")
    
    if rocksFolder then
        for _, region in ipairs(rocksFolder:GetChildren()) do
            for _, child in ipairs(region:GetChildren()) do
                if child.Name == "SpawnLocation" then
                    for _, model in ipairs(child:GetChildren()) do
                        if model:IsA("Model") and model:FindFirstChild("Hitbox") and not seen[model.Name] then
                            seen[model.Name] = true
                            table.insert(rockTypes, model.Name)
                        end
                    end
                elseif child:IsA("Model") and child:FindFirstChild("Hitbox") and not seen[child.Name] then
                    seen[child.Name] = true
                    table.insert(rockTypes, child.Name)
                end
            end
        end
    end
    table.sort(rockTypes)
    return rockTypes
end

local function FindNearestRock(maxDist)
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return nil end
    
    local root = char.HumanoidRootPart
    local closestRock = nil
    local bestDist = maxDist or 15
    local rocksFolder = Workspace:FindFirstChild("Rocks")

    if not rocksFolder or #MineTargets == 0 then return nil end

    for _, region in ipairs(rocksFolder:GetChildren()) do
        if AutoFarmRegionEnabled and #SelectedRegions > 0 then
            local regionMatch = false
            for _, selectedRegion in ipairs(SelectedRegions) do
                if region.Name == selectedRegion then
                    regionMatch = true
                    break
                end
            end
            if not regionMatch then
                continue
            end
        end
        
        for _, descendant in ipairs(region:GetDescendants()) do
            if descendant.Name == "Hitbox" and descendant:IsA("BasePart") and descendant.Parent then
                local isTargetRock = false
                for _, targetName in ipairs(MineTargets) do
                    if descendant.Parent.Name == targetName then
                        isTargetRock = true
                        break
                    end
                end
                
                if isTargetRock then
                    if SkipOresEnabled and HasSkippedOre(descendant.Parent) then
                        continue
                    end
                    
                    if AltFarmEnabled and AltFarmMode == "Helper Alt" and WhitelistOresEnabled then
                        local hasWhitelist, oreName = HasWhitelistOre(descendant.Parent)
                        if hasWhitelist then
                            local rockId = string.format("%.0f_%.0f_%.0f", 
                                descendant.Position.X, 
                                descendant.Position.Y, 
                                descendant.Position.Z)
                            
                            local infoFrame = descendant.Parent:FindFirstChild("infoFrame")
                            local hpText = infoFrame and infoFrame:FindFirstChild("Frame") and infoFrame.Frame:FindFirstChild("rockHP") and infoFrame.Frame.rockHP.Text
                            
                            local rockHasHP = true
                            if hpText then
                                local hp = tonumber(hpText:match("^(%d+)"))
                                if not hp or hp <= 0 then 
                                    rockHasHP = false
                                    NotifiedRocks[rockId] = nil
                                end
                            end
                            
                            if rockHasHP and not NotifiedRocks[rockId] then
                                NotifiedRocks[rockId] = true
                                NotifyMainAlt(descendant.Position, oreName)
                            end
                            continue
                        end
                    end
                    
                    local infoFrame = descendant.Parent:FindFirstChild("infoFrame")
                    local hpText = infoFrame and infoFrame:FindFirstChild("Frame") and infoFrame.Frame:FindFirstChild("rockHP") and infoFrame.Frame.rockHP.Text
                    
                    local isValid = true
                    if hpText then
                        local hp = tonumber(hpText:match("^(%d+)"))
                        if not hp or hp <= 0 then isValid = false end
                    end

                    if isValid then
                        local dist = (descendant.Position - root.Position).Magnitude
                        if dist < bestDist then
                            closestRock = descendant
                            bestDist = dist
                        end
                    end
                end
            end
        end
    end
    return closestRock
end

local function FastTweenToRock(rock)
    local char = LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local humanoid = char and char:FindFirstChild("Humanoid")
    
    if not root or not rock or not rock.Parent then return end
    
    if CurrentTween then
        CurrentTween:Cancel()
        CurrentTween = nil
    end
    
    IsTweening = true
    
    if MineBelowTarget and humanoid then
        humanoid.PlatformStand = true
        humanoid.Sit = true
    end
    
    local targetPos = rock.Position
    local goalPos, goalCFrame
    
    if MineBelowTarget then
        goalPos = targetPos + Vector3.new(0, -6, 0)
        goalCFrame = CFrame.new(goalPos) * CFrame.Angles(math.rad(90), 0, 0)
    else
        local offset = Vector3.new(MineDistanceOffset, 0, 0)
        goalPos = targetPos + offset
        goalCFrame = CFrame.lookAt(goalPos, targetPos)
    end
    
    local distance = (root.Position - goalCFrame.Position).Magnitude
    
    local isMainAltMode = AltFarmEnabled and AltFarmMode == "Main Alt"
    
    local tweenTime
    if isMainAltMode then
        if distance < 10 then
            tweenTime = distance / 10
        elseif distance < 30 then
            tweenTime = distance / 12
        elseif distance < 60 then
            tweenTime = distance / 15
        elseif distance < 100 then
            tweenTime = distance / 18
        else
            tweenTime = distance / 20
        end
    else
        if distance < 10 then
            tweenTime = distance / 20
        elseif distance < 30 then
            tweenTime = distance / 30
        elseif distance < 60 then
            tweenTime = distance / 40
        elseif distance < 100 then
            tweenTime = distance / 50
        else
            tweenTime = distance / 60
        end
    end
    
    tweenTime = math.max(0.5, math.min(tweenTime, 12))
    
    local tweenInfo = TweenInfo.new(
        tweenTime,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.InOut,
        0,
        false,
        0
    )
    
    local goal = {CFrame = goalCFrame}
    CurrentTween = TweenService:Create(root, tweenInfo, goal)
    
    CurrentTween.Completed:Connect(function()
        IsTweening = false
        CurrentTween = nil
    end)
    
    CurrentTween:Play()
end

task.spawn(function()
    while true do
        task.wait(10)
        
        if AltFarmEnabled and AltFarmMode == "Helper Alt" and WhitelistOresEnabled then
            local rocksFolder = Workspace:FindFirstChild("Rocks")
            if rocksFolder then
                local activeRockIds = {}
                
                for _, region in ipairs(rocksFolder:GetChildren()) do
                    for _, descendant in ipairs(region:GetDescendants()) do
                        if descendant.Name == "Hitbox" and descendant:IsA("BasePart") and descendant.Parent then
                            local rockId = string.format("%.0f_%.0f_%.0f", 
                                descendant.Position.X, 
                                descendant.Position.Y, 
                                descendant.Position.Z)
                            
                            local infoFrame = descendant.Parent:FindFirstChild("infoFrame")
                            local hpText = infoFrame and infoFrame:FindFirstChild("Frame") and infoFrame.Frame:FindFirstChild("rockHP") and infoFrame.Frame.rockHP.Text
                            
                            if hpText then
                                local hp = tonumber(hpText:match("^(%d+)"))
                                if hp and hp > 0 then
                                    activeRockIds[rockId] = true
                                end
                            end
                        end
                    end
                end
                
                for rockId, _ in pairs(NotifiedRocks) do
                    if not activeRockIds[rockId] then
                        NotifiedRocks[rockId] = nil
                    end
                end
            end
        end
    end
end)

task.spawn(function()
    local TextChatService = game:GetService("TextChatService")
    local Players = game:GetService("Players")
    
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        TextChatService.MessageReceived:Connect(function(message)
            if AltFarmEnabled and AltFarmMode == "Main Alt" then
                local text = message.Text
                
                if text:match("^WHITELISTROCK:") then
                    local data = text:match("WHITELISTROCK:(.+)")
                    if data then
                        local coords, oreName = data:match("([^:]+):(.+)")
                        if coords then
                            local x, y, z = coords:match("([^,]+),([^,]+),([^,]+)")
                            if x and y and z then
                                if AutoMineEnabled and ActiveMiningTarget and not IsMovingToWhitelistRock then
                                    PausedAutoMineTarget = ActiveMiningTarget
                                    AutoMineWasPaused = true
                                    UpdateAltFarmGUI("Paused auto-mine for priority", oreName or "Unknown", nil, "Priority", nil)
                                end
                                
                                MainAltCalledPosition = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
                                MainAltCalledOreName = oreName or "Unknown"
                                IsMovingToWhitelistRock = true
                                
                                UpdateAltFarmGUI("Received notification", MainAltCalledOreName, nil, "Active", nil)
                                
                                Fluent:Notify({
                                    Title = "Alt Farm - Main Alt",
                                    Content = "Received " .. MainAltCalledOreName .. " location!",
                                    SubContent = AutoMineWasPaused and "Paused auto-mine" or "Moving to location...",
                                    Duration = 5
                                })
                                
                                if CurrentTween then
                                    CurrentTween:Cancel()
                                    CurrentTween = nil
                                end
                                
                                ActiveMiningTarget = nil
                                
                                MineBelowTarget = true
                                SetNoclip(true)
                                SetupCharacterHighlight(true)
                                if not AutoMineEnabled then
                                    SetupCamera(true)
                                end
                            end
                        end
                    end
                end
            end
        end)
    else
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local DefaultChatSystemChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
        local OnMessageDoneFiltering = DefaultChatSystemChatEvents:WaitForChild("OnMessageDoneFiltering")
        
        OnMessageDoneFiltering.OnClientEvent:Connect(function(messageData)
            if AltFarmEnabled and AltFarmMode == "Main Alt" then
                local message = messageData.Message
                
                if message:match("^WHITELISTROCK:") then
                    local data = message:match("WHITELISTROCK:(.+)")
                    if data then
                        local coords, oreName = data:match("([^:]+):(.+)")
                        if coords then
                            local x, y, z = coords:match("([^,]+),([^,]+),([^,]+)")
                            if x and y and z then
                                if AutoMineEnabled and ActiveMiningTarget and not IsMovingToWhitelistRock then
                                    PausedAutoMineTarget = ActiveMiningTarget
                                    AutoMineWasPaused = true
                                    UpdateAltFarmGUI("Paused auto-mine for priority", oreName or "Unknown", nil, "Priority", nil)
                                end
                                
                                MainAltCalledPosition = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
                                MainAltCalledOreName = oreName or "Unknown"
                                IsMovingToWhitelistRock = true
                                
                                UpdateAltFarmGUI("Received notification", MainAltCalledOreName, nil, "Active", nil)
                                
                                Fluent:Notify({
                                    Title = "Alt Farm - Main Alt",
                                    Content = "Received " .. MainAltCalledOreName .. " location!",
                                    SubContent = AutoMineWasPaused and "Paused auto-mine" or "Moving to location...",
                                    Duration = 5
                                })
                                
                                if CurrentTween then
                                    CurrentTween:Cancel()
                                    CurrentTween = nil
                                end
                                
                                ActiveMiningTarget = nil
                                
                                MineBelowTarget = true
                                SetNoclip(true)
                                SetupCharacterHighlight(true)
                                if not AutoMineEnabled then
                                    SetupCamera(true)
                                end
                            end
                        end
                    end
                end
            end
        end)
    end
end)

task.spawn(function()
    while true do
        task.wait(0.1)
        if AltFarmEnabled and AltFarmMode == "Main Alt" and AltFarmGUI then
            local char = LocalPlayer.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            
            if root then
                if IsMovingToWhitelistRock and MainAltCalledPosition then
                    local distance = (root.Position - MainAltCalledPosition).Magnitude
                    UpdateAltFarmGUI(nil, nil, distance, nil, nil)
                elseif ActiveMiningTarget and ActiveMiningTarget.Parent then
                    local distance = (root.Position - ActiveMiningTarget.Position).Magnitude
                    UpdateAltFarmGUI(nil, nil, distance, nil, nil)
                else
                    UpdateAltFarmGUI(nil, nil, "--", nil, nil)
                end
                
                local notifiedCount = 0
                for _ in pairs(NotifiedRocks) do
                    notifiedCount = notifiedCount + 1
                end
                UpdateAltFarmGUI(nil, nil, nil, nil, notifiedCount)
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait()
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChild("Humanoid")
        
        local shouldMine = AutoMineEnabled or (AltFarmEnabled and AltFarmMode == "Main Alt" and (MainAltCalledPosition or ActiveMiningTarget))
        
        if shouldMine and MineBelowTarget and root and humanoid and ActiveMiningTarget and ActiveMiningTarget.Parent then
            humanoid.PlatformStand = true
            humanoid.Sit = true
            
            if char then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
            
            if not IsTweening then
                local targetPos = ActiveMiningTarget.Position
                local layPos = targetPos + Vector3.new(0, -6, 0)
                root.CFrame = CFrame.new(layPos) * CFrame.Angles(math.rad(90), 0, 0)
                root.Velocity = Vector3.new(0, 0, 0)
                root.RotVelocity = Vector3.new(0, 0, 0)
                root.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            end
        elseif humanoid then
            if not (AltFarmEnabled and AltFarmMode == "Main Alt" and IsMovingToWhitelistRock) then
                humanoid.PlatformStand = false
                humanoid.Sit = false
            end
        end
    end
end)

task.spawn(function()
    while true do
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChild("Humanoid")

        local shouldMine = AutoMineEnabled or (AltFarmEnabled and AltFarmMode == "Main Alt" and (MainAltCalledPosition or ActiveMiningTarget))

        if shouldMine and ToolActivated and root and humanoid then
            if AltFarmEnabled and AltFarmMode == "Main Alt" and MainAltCalledPosition and IsMovingToWhitelistRock then
                local rocksFolder = Workspace:FindFirstChild("Rocks")
                if rocksFolder then
                    local closestRockToCall = nil
                    local bestDist = 50
                    local foundOreName = ""
                    
                    for _, region in ipairs(rocksFolder:GetChildren()) do
                        for _, descendant in ipairs(region:GetDescendants()) do
                            if descendant.Name == "Hitbox" and descendant:IsA("BasePart") and descendant.Parent then
                                local dist = (descendant.Position - MainAltCalledPosition).Magnitude
                                if dist < bestDist then
                                    local infoFrame = descendant.Parent:FindFirstChild("infoFrame")
                                    local hpText = infoFrame and infoFrame:FindFirstChild("Frame") and infoFrame.Frame:FindFirstChild("rockHP") and infoFrame.Frame.rockHP.Text
                                    
                                    local isValid = true
                                    if hpText then
                                        local hp = tonumber(hpText:match("^(%d+)"))
                                        if not hp or hp <= 0 then isValid = false end
                                    end
                                    
                                    if isValid then
                                        local hasWhitelist, oreName = HasWhitelistOre(descendant.Parent)
                                        if hasWhitelist then
                                            closestRockToCall = descendant
                                            bestDist = dist
                                            foundOreName = oreName or MainAltCalledOreName
                                        end
                                    end
                                end
                            end
                        end
                    end
                    
                    if closestRockToCall then
                        ActiveMiningTarget = closestRockToCall
                        IsMovingToWhitelistRock = false
                        UpdateAltFarmGUI("Moving to priority target", foundOreName, nil, "Traveling", nil)
                        FastTweenToRock(ActiveMiningTarget)
                        MainAltCalledPosition = nil
                    else
                        UpdateAltFarmGUI("Searching for priority rock", MainAltCalledOreName, nil, "Searching", nil)
                    end
                end
            end
            
            local pickaxe = char:FindFirstChild("Pickaxe")
            if not pickaxe then
                local backpackPick = LocalPlayer.Backpack:FindFirstChild("Pickaxe")
                if backpackPick then
                    humanoid:EquipTool(backpackPick)
                    task.wait(0.05)
                    pickaxe = char:FindFirstChild("Pickaxe")
                end
            end

            local targetValid = false
            if ActiveMiningTarget and ActiveMiningTarget.Parent then
                local isTarget = false
                
                if AltFarmEnabled and AltFarmMode == "Main Alt" then
                    isTarget = true
                else
                    for _, targetName in ipairs(MineTargets) do
                        if ActiveMiningTarget.Parent.Name == targetName then
                            isTarget = true
                            break
                        end
                    end
                end
                
                if isTarget then
                    if SkipOresEnabled and HasSkippedOre(ActiveMiningTarget.Parent) then
                        targetValid = false
                        ActiveMiningTarget = nil
                    elseif AltFarmEnabled and AltFarmMode == "Helper Alt" and WhitelistOresEnabled then
                        local hasWhitelist = HasWhitelistOre(ActiveMiningTarget.Parent)
                        if hasWhitelist then
                            targetValid = false
                            ActiveMiningTarget = nil
                        else
                            local infoFrame = ActiveMiningTarget.Parent:FindFirstChild("infoFrame")
                            local hpText = infoFrame and infoFrame:FindFirstChild("Frame") and infoFrame.Frame:FindFirstChild("rockHP") and infoFrame.Frame.rockHP.Text
                            if hpText then
                                local hp = tonumber(hpText:match("^(%d+)"))
                                if hp and hp > 0 then 
                                    targetValid = true 
                                else
                                    if AltFarmEnabled and AltFarmMode == "Main Alt" then
                                        if AutoMineWasPaused and PausedAutoMineTarget then
                                            UpdateAltFarmGUI("Resuming auto-mine", "Auto", nil, "Resuming", nil)
                                            ActiveMiningTarget = PausedAutoMineTarget
                                            PausedAutoMineTarget = nil
                                            AutoMineWasPaused = false
                                            
                                            Fluent:Notify({
                                                Title = "Alt Farm - Main Alt",
                                                Content = "Priority complete!",
                                                SubContent = "Resuming auto-mine...",
                                                Duration = 3
                                            })
                                        else
                                            UpdateAltFarmGUI("Priority complete", "None", nil, "Standby", nil)
                                        end
                                        MainAltCalledPosition = nil
                                        IsMovingToWhitelistRock = false
                                    end
                                end
                            else
                                targetValid = true
                            end
                        end
                    else
                        local infoFrame = ActiveMiningTarget.Parent:FindFirstChild("infoFrame")
                        local hpText = infoFrame and infoFrame:FindFirstChild("Frame") and infoFrame.Frame:FindFirstChild("rockHP") and infoFrame.Frame.rockHP.Text
                        if hpText then
                            local hp = tonumber(hpText:match("^(%d+)"))
                            if hp and hp > 0 then 
                                targetValid = true 
                            else
                                if AltFarmEnabled and AltFarmMode == "Main Alt" then
                                    if AutoMineWasPaused and PausedAutoMineTarget then
                                        UpdateAltFarmGUI("Resuming auto-mine", "Auto", nil, "Resuming", nil)
                                        ActiveMiningTarget = PausedAutoMineTarget
                                        PausedAutoMineTarget = nil
                                        AutoMineWasPaused = false
                                        
                                        Fluent:Notify({
                                            Title = "Alt Farm - Main Alt",
                                            Content = "Priority complete!",
                                            SubContent = "Resuming auto-mine...",
                                            Duration = 3
                                        })
                                    else
                                        UpdateAltFarmGUI("Priority complete", "None", nil, "Standby", nil)
                                    end
                                    MainAltCalledPosition = nil
                                    IsMovingToWhitelistRock = false
                                end
                            end
                        else
                            targetValid = true
                        end
                    end
                end
            end

            if not targetValid then
                ActiveMiningTarget = nil
                if CurrentTween then
                    CurrentTween:Cancel()
                    CurrentTween = nil
                end
                IsTweening = false
                
                if AltFarmEnabled and AltFarmMode == "Main Alt" and AltFarmGUI then
                    if not MainAltCalledPosition and not IsMovingToWhitelistRock then
                        if AutoMineEnabled then
                            UpdateAltFarmGUI("Auto-mine active", "Auto", nil, "Auto-Mining", nil)
                        else
                            UpdateAltFarmGUI("Waiting for notification", "None", nil, "Standby", nil)
                        end
                    end
                end
            end

            if not ActiveMiningTarget and AutoMineEnabled and not IsMovingToWhitelistRock then
                ActiveMiningTarget = FindNearestRock(500)
                if ActiveMiningTarget then
                    FastTweenToRock(ActiveMiningTarget)
                end
            end

            if pickaxe and ActiveMiningTarget and humanoid.Health > 0 and ActiveMiningTarget.Parent then
                local dist = (root.Position - ActiveMiningTarget.Position).Magnitude
                
                if dist > 30 and not IsTweening then
                    FastTweenToRock(ActiveMiningTarget)
                    if AltFarmEnabled and AltFarmMode == "Main Alt" then
                        local targetType = IsMovingToWhitelistRock and "priority rock" or (AutoMineEnabled and "auto-mine rock" or "rock")
                        UpdateAltFarmGUI("Moving to " .. targetType, MainAltCalledOreName or "Ore", dist, "Traveling", nil)
                    end
                end
                
                if dist <= 30 then
                    if AltFarmEnabled and AltFarmMode == "Main Alt" and not IsTweening then
                        local miningType = AutoMineWasPaused and "priority" or (AutoMineEnabled and "auto-mine" or "priority")
                        UpdateAltFarmGUI("Mining " .. miningType, MainAltCalledOreName or "Ore", dist, "Mining", nil)
                    end
                    
                    for i = 1, 3 do
                        pcall(function()
                            ToolActivated:InvokeServer("Pickaxe")
                        end)
                    end
                end
            end
        else
            if not (AltFarmEnabled and AltFarmMode == "Main Alt" and (MainAltCalledPosition or ActiveMiningTarget)) then
                ActiveMiningTarget = nil
                if CurrentTween then
                    CurrentTween:Cancel()
                    CurrentTween = nil
                end
                IsTweening = false
            end
        end
        
        task.wait()
    end
end)

Tabs.Main:AddSection("Auto Farm Rocks")

Tabs.Main:AddToggle("AutoMineToggle", {
    Title = "Auto Mine",
    Description = "",
    Default = false,
    Callback = function(state)
        AutoMineEnabled = state
        if not state then
            if not (AltFarmEnabled and AltFarmMode == "Main Alt") then
                ActiveMiningTarget = nil
                if CurrentTween then
                    CurrentTween:Cancel()
                    CurrentTween = nil
                end
                IsTweening = false
                SetNoclip(false)
                SetupCamera(false)
                
                local char = LocalPlayer.Character
                local humanoid = char and char:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.PlatformStand = false
                end
            end
            
            PausedAutoMineTarget = nil
            AutoMineWasPaused = false
        else
            SetupCamera(true)
        end
    end
})

Tabs.Main:AddToggle("MineBelowToggle", {
    Title = "Mine Below Target",
    Description = "",
    Default = false,
    Callback = function(state)
        MineBelowTarget = state
        SetNoclip(state)
        SetupCharacterHighlight(state)
        
        if not state then
            local char = LocalPlayer.Character
            local humanoid = char and char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.PlatformStand = false
                humanoid.Sit = false
            end
        end
        
        if not (AltFarmEnabled and AltFarmMode == "Main Alt") then
            ActiveMiningTarget = nil
        end
    end
})

Tabs.Main:AddSlider("MineDistanceSlider", {
    Title = "Distance Offset",
    Description = "",
    Default = 4,
    Min = 1,
    Max = 20,
    Rounding = 0,
    Callback = function(Value)
        MineDistanceOffset = Value
    end
})

local miningDropdownValues = RockTypes
if #miningDropdownValues == 0 then
    miningDropdownValues = {""}
end

MineDropdownRef = Tabs.Main:AddDropdown("MineTargetDropdown", {
    Title = "Mining Targets",
    Description = "",
    Values = miningDropdownValues,
    Multi = true,
    Default = {""},
    Callback = function(value)
        MineTargets = {}
        if typeof(value) == "table" then
            for rockKey, isSelected in pairs(value) do
                if isSelected then
                    table.insert(MineTargets, rockKey)
                end
            end
        end
        
        if #MineTargets == 0 then
            if not (AltFarmEnabled and AltFarmMode == "Main Alt") then
                ActiveMiningTarget = nil
                if CurrentTween then
                    CurrentTween:Cancel()
                    CurrentTween = nil
                end
                IsTweening = false
            end
        else
            if not (AltFarmEnabled and AltFarmMode == "Main Alt") then
                ActiveMiningTarget = nil
            end
        end
    end
})

Tabs.Main:AddButton({
    Title = "Refresh Mining Targets",
    Description = "",
    Callback = function()
        RockTypes = GetRockTypes()
        MineDropdownRef:SetValues(RockTypes)
    end
})

local oreTypes = GetOreTypes()
if #oreTypes == 0 then
    oreTypes = {""}
end

Tabs.Main:AddSection("Auto Skip Ores")

local OreDropdownRef = Tabs.Main:AddDropdown("SkipOresDropdown", {
    Title = "Ores to Skip",
    Description = "",
    Values = oreTypes,
    Multi = true,
    Default = {""},
    Callback = function(value)
        SkipOres = {}
        if typeof(value) == "table" then
            for oreKey, isSelected in pairs(value) do
                if isSelected then
                    table.insert(SkipOres, oreKey)
                end
            end
        end
        
        if ActiveMiningTarget then
            ActiveMiningTarget = nil
        end
    end
})

Tabs.Main:AddDropdown("SkipLogicDropdown", {
    Title = "Skip Logic",
    Description = "",
    Values = {"Skip If Any", "Skip If All"},
    Multi = false,
    Default = 1,
    Callback = function(value)
        SkipLogic = value
        
        if ActiveMiningTarget then
            ActiveMiningTarget = nil
        end
    end
})

Tabs.Main:AddToggle("SkipOresToggle", {
    Title = "Skip Selected Ores",
    Description = "",
    Default = false,
    Callback = function(state)
        SkipOresEnabled = state
        
        if ActiveMiningTarget then
            ActiveMiningTarget = nil
        end
    end
})

Tabs.Main:AddParagraph({
    Title = "Skip Logic Explained",
    Content = "Skip If Any: Skips rock if it contains ANY selected ore\n\nSkip If All: Only skips if ALL ores in the rock are selected"
})

Tabs.Main:AddSection("Auto Farm Region")

Tabs.Main:AddToggle("AutoFarmRegionToggle", {
    Title = "Auto Farm Region",
    Description = "",
    Default = false,
    Callback = function(state)
        AutoFarmRegionEnabled = state
        
        if not state then
            SelectedRegions = {}
        end
        
        if ActiveMiningTarget then
            ActiveMiningTarget = nil
        end
    end
})

local regionList = GetRegions()
if #regionList == 0 then
    regionList = {""}
end

local RegionDropdownRef = Tabs.Main:AddDropdown("RegionTargetDropdown", {
    Title = "Select Regions",
    Description = "",
    Values = regionList,
    Multi = true,
    Default = {""},
    Callback = function(value)
        SelectedRegions = {}
        if typeof(value) == "table" then
            for regionKey, isSelected in pairs(value) do
                if isSelected then
                    table.insert(SelectedRegions, regionKey)
                end
            end
        end
        
        if ActiveMiningTarget then
            ActiveMiningTarget = nil
        end
    end
})

Tabs.Main:AddButton({
    Title = "Refresh Regions",
    Description = "",
    Callback = function()
        local newRegions = GetRegions()
        RegionDropdownRef:SetValues(newRegions)
    end
})

Tabs.Main:AddParagraph({
    Title = "Region Farming",
    Content = "When enabled, auto mining will only target rocks within selected regions."
})

Tabs.Main:AddSection("Alt Farm System")

Tabs.Main:AddToggle("AltFarmToggle", {
    Title = "Enable Alt Farm",
    Description = "",
    Default = false,
    Callback = function(state)
        AltFarmEnabled = state
        
        if state then
            if AltFarmMode == "Main Alt" then
                CreateAltFarmGUI()
                UpdateAltFarmGUI("Waiting for notification", "None", "--", "Standby", 0)
            end
            
            Fluent:Notify({
                Title = "Alt Farm Enabled",
                Content = "Mode: " .. AltFarmMode,
                SubContent = AltFarmMode == "Helper Alt" and "Will notify main alt" or "Waiting for notifications",
                Duration = 5
            })
        else
            NotifiedRocks = {}
            MainAltCalledPosition = nil
            MainAltCalledOreName = ""
            IsMovingToWhitelistRock = false
            LastNotificationTime = 0
            PausedAutoMineTarget = nil
            AutoMineWasPaused = false
            
            if AltFarmGUI then
                AltFarmGUI:Destroy()
                AltFarmGUI = nil
            end
            
            SetNoclip(false)
            SetupCharacterHighlight(false)
            if not AutoMineEnabled then
                SetupCamera(false)
            end
            
            local char = LocalPlayer.Character
            local humanoid = char and char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.PlatformStand = false
                humanoid.Sit = false
            end
            
            Fluent:Notify({
                Title = "Alt Farm Disabled",
                Content = "System turned off",
                Duration = 3
            })
        end
        
        if not AutoMineEnabled then
            ActiveMiningTarget = nil
        end
    end
})

Tabs.Main:AddDropdown("AltFarmModeDropdown", {
    Title = "Alt Farm Mode",
    Description = "",
    Values = {"Helper Alt", "Main Alt"},
    Multi = false,
    Default = 1,
    Callback = function(value)
        AltFarmMode = value
        
        if AltFarmEnabled and value == "Main Alt" then
            CreateAltFarmGUI()
            UpdateAltFarmGUI("Waiting for notification", "None", "--", "Standby", 0)
        elseif AltFarmGUI then
            AltFarmGUI:Destroy()
            AltFarmGUI = nil
        end
        
        Fluent:Notify({
            Title = "Alt Farm Mode Changed",
            Content = "Now: " .. value,
            SubContent = value == "Helper Alt" and "Will find and notify" or "Will receive and mine",
            Duration = 4
        })
        
        NotifiedRocks = {}
        MainAltCalledPosition = nil
        MainAltCalledOreName = ""
        IsMovingToWhitelistRock = false
        LastNotificationTime = 0
        PausedAutoMineTarget = nil
        AutoMineWasPaused = false
        
        if not AutoMineEnabled then
            ActiveMiningTarget = nil
        end
    end
})

Tabs.Main:AddInput("AltNameInput", {
    Title = "Alt Account Name",
    Description = "Enter exact Roblox username",
    Default = "",
    Placeholder = "Username",
    Numeric = false,
    Finished = true,
    Callback = function(Value)
        MainAltName = Value
        
        if Value ~= "" then
            Fluent:Notify({
                Title = "Alt Name Set",
                Content = "Partner: " .. Value,
                SubContent = AltFarmMode == "Helper Alt" and "Will send to this account" or "Will listen from this account",
                Duration = 4
            })
        end
    end
})

local whitelistOreTypes = GetOreTypes()
if #whitelistOreTypes == 0 then
    whitelistOreTypes = {""}
end

local WhitelistOreDropdownRef = Tabs.Main:AddDropdown("WhitelistOresDropdown", {
    Title = "Whitelist Ores",
    Description = "Ores for alt farm",
    Values = whitelistOreTypes,
    Multi = true,
    Default = {""},
    Callback = function(value)
        WhitelistOres = {}
        if typeof(value) == "table" then
            for oreKey, isSelected in pairs(value) do
                if isSelected then
                    table.insert(WhitelistOres, oreKey)
                end
            end
        end
        
        NotifiedRocks = {}
        
        if #WhitelistOres > 0 then
            local oreList = table.concat(WhitelistOres, ", ")
            Fluent:Notify({
                Title = "Whitelist Updated",
                Content = "Selected: " .. oreList,
                Duration = 5
            })
        end
        
        if ActiveMiningTarget then
            ActiveMiningTarget = nil
        end
    end
})

Tabs.Main:AddToggle("WhitelistOresToggle", {
    Title = "Enable Whitelist Ores",
    Description = "",
    Default = false,
    Callback = function(state)
        WhitelistOresEnabled = state
        NotifiedRocks = {}
        
        if state then
            Fluent:Notify({
                Title = "Whitelist Enabled",
                Content = AltFarmMode == "Helper Alt" and "Will skip and notify" or "Ready to receive",
                Duration = 4
            })
        else
            Fluent:Notify({
                Title = "Whitelist Disabled",
                Content = "Normal mining resumed",
                Duration = 3
            })
        end
        
        if ActiveMiningTarget then
            ActiveMiningTarget = nil
        end
    end
})

Tabs.Main:AddButton({
    Title = "Refresh Whitelist Ores",
    Description = "",
    Callback = function()
        local newOreTypes = GetOreTypes()
        WhitelistOreDropdownRef:SetValues(newOreTypes)
        
        Fluent:Notify({
            Title = "Ores Refreshed",
            Content = "List updated",
            Duration = 3
        })
    end
})

Tabs.Main:AddButton({
    Title = "Clear Notified Rocks",
    Description = "Reset notification tracking",
    Callback = function()
        NotifiedRocks = {}
        LastNotificationTime = 0
        
        Fluent:Notify({
            Title = "Tracking Cleared",
            Content = "All rocks can be notified again",
            Duration = 3
        })
    end
})

Tabs.Main:AddParagraph({
    Title = "Alt Farm Guideiop",
    Content = "Helper Alt: Mines normally but notifies Main Alt about whitelist ores.\n\nMain Alt: Auto-mines whitelist ores when notified (Auto Mine can be OFF!).\n\nBoth must be in same game!\n\nPriority System: When Main Alt receives notification during auto-mine, it pauses current rock, mines priority ore, then resumes where it left off.\n\nMain Alt moves slower than normal auto mine for smoother travel.\n\nCooldown: 2 seconds between notifications to prevent spam."
})


-- Auto Attack Tab
local AutoAttackEnabled = false
local AttackTarget = ""
local ActiveAttackTarget = nil
local MobTypes = {}
local AttackTween = nil
local IsAttackTweening = false
local AttackTweenSpeed = 25
local AttackDistance = 6
local AttackDropdownRef = nil
local AttackBelowTarget = false
local AttackNoclipConnection = nil
local AttackCameraConnection = nil
local OriginalAttackCameraSettings = {}
local AttackCharacterHighlight = nil
local LastTargetChangeTime = 0
local TARGET_CHANGE_COOLDOWN = 2 

local function SetupAttackCharacterHighlight(enabled)
    if AttackCharacterHighlight then
        AttackCharacterHighlight:Destroy()
        AttackCharacterHighlight = nil
    end
    
    if enabled then
        local char = LocalPlayer.Character
        if char then
            AttackCharacterHighlight = Instance.new("Highlight")
            AttackCharacterHighlight.Name = "AttackHighlight"
            AttackCharacterHighlight.FillColor = Color3.fromRGB(255, 0, 0)
            AttackCharacterHighlight.OutlineColor = Color3.fromRGB(255, 100, 100)
            AttackCharacterHighlight.FillTransparency = 0.5
            AttackCharacterHighlight.OutlineTransparency = 0
            AttackCharacterHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            AttackCharacterHighlight.Parent = char
        end
    end
end

local function SetupAttackCamera(enabled)
    local camera = workspace.CurrentCamera
    
    if AttackCameraConnection then
        AttackCameraConnection:Disconnect()
        AttackCameraConnection = nil
    end
    
    if enabled then
        OriginalAttackCameraSettings = {
            CameraType = camera.CameraType,
            CameraSubject = camera.CameraSubject
        }
        
        camera.CameraType = Enum.CameraType.Custom
        
        AttackCameraConnection = game:GetService("RunService").RenderStepped:Connect(function()
            local char = LocalPlayer.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local humanoid = char and char:FindFirstChild("Humanoid")
            
            if char and root and humanoid then
                if AttackBelowTarget and ActiveAttackTarget and ActiveAttackTarget.Parent then
                    local targetRoot = ActiveAttackTarget:FindFirstChild("HumanoidRootPart")
                    if targetRoot then
                        local targetPos = targetRoot.Position
                        local cameraHeight = 15
                        local cameraOffset = Vector3.new(0, cameraHeight, 10)
                        local desiredCameraPos = targetPos + cameraOffset
                        local lookAtPos = targetPos + Vector3.new(0, 2, 0)
                        
                        local raycastParams = RaycastParams.new()
                        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                        raycastParams.FilterDescendantsInstances = {char, workspace.Living}
                        
                        local rayResult = workspace:Raycast(targetPos, (desiredCameraPos - targetPos).Unit * cameraHeight, raycastParams)
                        
                        local finalCameraPos = desiredCameraPos
                        
                        if rayResult then
                            local alternativeOffsets = {
                                Vector3.new(0, cameraHeight, -10),
                                Vector3.new(10, cameraHeight, 0),  
                                Vector3.new(-10, cameraHeight, 0), 
                                Vector3.new(7, cameraHeight, 7),
                                Vector3.new(-7, cameraHeight, 7),
                                Vector3.new(7, cameraHeight, -7),
                                Vector3.new(-7, cameraHeight, -7),
                                Vector3.new(0, cameraHeight + 5, 0)
                            }
                            
                            for _, offset in ipairs(alternativeOffsets) do
                                local testPos = targetPos + offset
                                local testRay = workspace:Raycast(targetPos, (testPos - targetPos).Unit * offset.Magnitude, raycastParams)
                                
                                if not testRay then
                                    finalCameraPos = testPos
                                    break
                                end
                            end
                        end
                        
                        camera.CFrame = CFrame.new(finalCameraPos, lookAtPos)
                    end
                else
                    if camera.CameraSubject ~= humanoid then
                        camera.CameraSubject = humanoid
                    end
                    
                    local targetCFrame = camera.CFrame
                    local targetPos = targetCFrame.Position
                    local rootPos = root.Position
                    
                    local rayDirection = (targetPos - rootPos)
                    local rayLength = rayDirection.Magnitude
                    
                    if rayLength > 0 then
                        local raycastParams = RaycastParams.new()
                        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                        raycastParams.FilterDescendantsInstances = {char, workspace.Living}
                        
                        local rayResult = workspace:Raycast(rootPos, rayDirection.Unit * rayLength, raycastParams)
                        
                        if rayResult then
                            local safeDistance = (rayResult.Position - rootPos).Magnitude - 0.5
                            if safeDistance < rayLength then
                                local newPos = rootPos + rayDirection.Unit * math.max(safeDistance, 0.5)
                                camera.CFrame = CFrame.new(newPos, rootPos)
                            end
                        end
                    end
                    
                    if targetPos.Y < rootPos.Y - 2 then
                        local correctedPos = Vector3.new(targetPos.X, rootPos.Y - 2, targetPos.Z)
                        camera.CFrame = CFrame.new(correctedPos, rootPos)
                    end
                end
                
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.LocalTransparencyModifier = 0
                    end
                end
            end
        end)
    else
        if OriginalAttackCameraSettings.CameraType then
            camera.CameraType = OriginalAttackCameraSettings.CameraType
        end
        if OriginalAttackCameraSettings.CameraSubject then
            camera.CameraSubject = OriginalAttackCameraSettings.CameraSubject
        end
        
        local char = LocalPlayer.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.LocalTransparencyModifier = 0
                end
            end
        end
    end
end

local function SetAttackNoclip(enabled)
    if AttackNoclipConnection then
        AttackNoclipConnection:Disconnect()
        AttackNoclipConnection = nil
    end
    
    if enabled then
        local char = LocalPlayer.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
        
        AttackNoclipConnection = game:GetService("RunService").Stepped:Connect(function()
            local char = LocalPlayer.Character
            if char then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        local char = LocalPlayer.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.CanCollide = true
                end
            end
        end
    end
end

local function GetMobTypes()
    local mobs = {}
    local seen = {}
    local living = Workspace:FindFirstChild("Living")
    
    if living then
        for _, model in ipairs(living:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChild("Humanoid") and not model:FindFirstChild("RaceFolder") and not model:FindFirstChild("Animate") then
                local name = model.Name:gsub("%d+$", "")
                if not seen[name] then
                    seen[name] = true
                    table.insert(mobs, name)
                end
            end
        end
    end
    table.sort(mobs)
    return mobs
end

local function IsTargetValid(target)
    if not target or not target.Parent then return false end
    
    local humanoid = target:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    
    local cleanName = target.Name:gsub("%d+$", "")
    if cleanName ~= AttackTarget then return false end
    
    if target:FindFirstChild("RaceFolder") or target:FindFirstChild("Animate") then return false end
    
    return true
end

local function FindNearestMob(maxDist)
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return nil end
    
    local root = char.HumanoidRootPart
    local bestTarget = nil
    local bestDist = maxDist or 100
    
    local living = Workspace:FindFirstChild("Living")
    if not living then return nil end

    for _, mob in ipairs(living:GetChildren()) do
        if mob:IsA("Model") and mob:FindFirstChild("Humanoid") then
            local cleanName = mob.Name:gsub("%d+$", "")
            
            if cleanName == AttackTarget and not mob:FindFirstChild("RaceFolder") 
               and not mob:FindFirstChild("Animate") and mob.Humanoid.Health > 0 
               and mob:FindFirstChild("HumanoidRootPart") then
                
                local mobRoot = mob.HumanoidRootPart
                local dist = (mobRoot.Position - root.Position).Magnitude
                if dist < bestDist then
                    bestTarget = mob
                    bestDist = dist
                end
            end
        end
    end
    return bestTarget
end

local function GetMobBackPosition(mob)
    if not mob or not mob:FindFirstChild("HumanoidRootPart") then return nil end
    
    local mobRoot = mob.HumanoidRootPart
    
    if AttackBelowTarget then
        local belowPosition = mobRoot.Position + Vector3.new(0, -6, 0)
        return belowPosition, mobRoot.Position
    else
        local lookVector = mobRoot.CFrame.LookVector
        local behindOffset = lookVector * -AttackDistance
        behindOffset = behindOffset + Vector3.new(0, 0, 0)
        local targetPosition = mobRoot.Position + behindOffset
        return targetPosition, mobRoot.Position
    end
end

local function TweenBehindMob(mob)
    local char = LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local humanoid = char and char:FindFirstChild("Humanoid")
    
    if not root or not mob or not mob:FindFirstChild("HumanoidRootPart") then return end
    
    if AttackTween then
        AttackTween:Cancel()
        AttackTween = nil
    end
    
    IsAttackTweening = true
    
    if AttackBelowTarget and humanoid then
        humanoid.PlatformStand = true
        humanoid.Sit = true
    end
    
    local targetPosition, mobPosition = GetMobBackPosition(mob)
    if not targetPosition then 
        IsAttackTweening = false
        return 
    end
    
    local distance = (root.Position - targetPosition).Magnitude
    
    local tweenTime = distance / AttackTweenSpeed
    
    local minTime
    if distance < 15 then
        minTime = 1.2  
    elseif distance < 30 then
        minTime = 1.5 
    else
        minTime = math.min(1.5, distance / 50)
    end
    
    tweenTime = math.max(minTime, math.min(tweenTime, 15))
    
    local tweenInfo = TweenInfo.new(
        tweenTime,
        Enum.EasingStyle.Sine, 
        Enum.EasingDirection.InOut,  
        0,
        false,
        0
    )
    
    local goalCFrame
    if AttackBelowTarget then
        goalCFrame = CFrame.new(targetPosition) * CFrame.Angles(math.rad(90), 0, 0)
    else
        goalCFrame = CFrame.new(targetPosition, mobPosition)
    end
    
    local goal = {CFrame = goalCFrame}
    AttackTween = TweenService:Create(root, tweenInfo, goal)
    
    AttackTween.Completed:Connect(function()
        IsAttackTweening = false
        AttackTween = nil
    end)
    
    AttackTween:Play()
end

local function MaintainBehindPosition(mob)
    if not mob or not mob:FindFirstChild("HumanoidRootPart") then return end
    
    local char = LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    
    local targetPosition, mobPosition = GetMobBackPosition(mob)
    if not targetPosition then return end
    
    local currentDistance = (root.Position - targetPosition).Magnitude
    
    if currentDistance > 2 and not IsAttackTweening then
        TweenBehindMob(mob)
    elseif not AttackBelowTarget then
        root.CFrame = CFrame.new(root.Position, mobPosition)
    end
end

task.spawn(function()
    while true do
        task.wait()
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChild("Humanoid")
        
        if AutoAttackEnabled and AttackBelowTarget and root and humanoid and ActiveAttackTarget and ActiveAttackTarget.Parent then
            humanoid.PlatformStand = true
            humanoid.Sit = true
            
            if char then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
            
            if not IsAttackTweening then
                local targetPos = ActiveAttackTarget:FindFirstChild("HumanoidRootPart")
                if targetPos then
                    local layPos = targetPos.Position + Vector3.new(0, -6, 0)
                    root.CFrame = CFrame.new(layPos) * CFrame.Angles(math.rad(90), 0, 0)
                    root.Velocity = Vector3.new(0, 0, 0)
                    root.RotVelocity = Vector3.new(0, 0, 0)
                    root.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                end
            end
        elseif humanoid then
            humanoid.PlatformStand = false
            humanoid.Sit = false
        end
    end
end)

task.spawn(function()
    while true do
        task.wait(0.01)
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChild("Humanoid")
        
        if AutoAttackEnabled and ToolActivated and root and humanoid and humanoid.Health > 0 then
            local weapon = char:FindFirstChildWhichIsA("Tool")
            if not weapon or weapon.Name == "Pickaxe" or weapon.Name == "Hammer" then
                for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
                    if tool:IsA("Tool") and tool.Name ~= "Pickaxe" and tool.Name ~= "Hammer" then
                        humanoid:EquipTool(tool)
                        weapon = tool
                        break
                    end
                end
            end

            local currentTime = tick()
            local shouldFindNewTarget = false
            
            if ActiveAttackTarget then
                if not IsTargetValid(ActiveAttackTarget) then
                    ActiveAttackTarget = nil
                    LastTargetChangeTime = currentTime
                    shouldFindNewTarget = true
                end
            else
                if currentTime - LastTargetChangeTime >= TARGET_CHANGE_COOLDOWN then
                    shouldFindNewTarget = true
                end
            end

            if shouldFindNewTarget and not ActiveAttackTarget then
                local newTarget = FindNearestMob(500)
                if newTarget then
                    ActiveAttackTarget = newTarget
                    LastTargetChangeTime = currentTime
                    TweenBehindMob(ActiveAttackTarget)
                end
            end

            local target = ActiveAttackTarget

            if weapon and target and humanoid.Health > 0 and target.Parent then
                MaintainBehindPosition(target)
                
                local targetRoot = target:FindFirstChild("HumanoidRootPart")
                if targetRoot then
                    local dist = (root.Position - targetRoot.Position).Magnitude
                    
                    if dist > 20 and not IsAttackTweening and IsTargetValid(target) then
                        TweenBehindMob(target)
                    elseif dist > 8 and dist <= 20 and not IsAttackTweening and IsTargetValid(target) then
                        TweenBehindMob(target)
                    end
                    
                    if dist <= 20 then
                        ToolActivated:InvokeServer("Weapon")
                    end
                end
            end
        else
            ActiveAttackTarget = nil
            if AttackTween then
                AttackTween:Cancel()
                AttackTween = nil
            end
            IsAttackTweening = false
            SetAttackNoclip(false)
        end
    end
end)

Tabs.AutoAttack:AddSection("Auto Attack Settings")

Tabs.AutoAttack:AddToggle("AutoAttackToggle", {
    Title = "Auto Attack",
    Description = "",
    Default = false,
    Callback = function(state)
        AutoAttackEnabled = state
        if not state then
            ActiveAttackTarget = nil
            LastTargetChangeTime = 0
            if AttackTween then
                AttackTween:Cancel()
                AttackTween = nil
            end
            IsAttackTweening = false
            SetAttackNoclip(false)
            SetupAttackCamera(false)
            
            local char = LocalPlayer.Character
            local humanoid = char and char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.PlatformStand = false
                humanoid.Sit = false
            end
        else
            SetupAttackCamera(true)
        end
    end
})

Tabs.AutoAttack:AddToggle("AttackBelowToggle", {
    Title = "Attack Below Target",
    Description = "",
    Default = false,
    Callback = function(state)
        AttackBelowTarget = state
        SetAttackNoclip(state)
        SetupAttackCharacterHighlight(state)
        
        if not state then
            local char = LocalPlayer.Character
            local humanoid = char and char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.PlatformStand = false
                humanoid.Sit = false
            end
        end
        
        ActiveAttackTarget = nil
    end
})

Tabs.AutoAttack:AddSlider("AttackTweenSpeedSlider", {
    Title = "Tween Speed",
    Description = "",
    Default = 25,
    Min = 10,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        AttackTweenSpeed = Value
    end
})

Tabs.AutoAttack:AddSlider("AttackDistanceSlider", {
    Title = "Behind Distance",
    Description = "",
    Default = 6,
    Min = 3,
    Max = 15,
    Rounding = 0,
    Callback = function(Value)
        AttackDistance = Value
    end
})

task.spawn(function()
    task.wait(1)
    
    local attackDropdownValues = MobTypes
    if #attackDropdownValues == 0 then
        attackDropdownValues = {"Zombie"}
    end
    
    AttackDropdownRef = Tabs.AutoAttack:AddDropdown("AttackTargetDropdown", {
        Title = "Attack Target",
        Description = "",
        Values = attackDropdownValues,
        Multi = false,
        Default = AttackTarget,
        Callback = function(value)
            AttackTarget = value
            ActiveAttackTarget = nil
            LastTargetChangeTime = 0
            if AttackTween then
                AttackTween:Cancel()
                AttackTween = nil
            end
            IsAttackTweening = false
        end
    })
    
    Tabs.AutoAttack:AddButton({
        Title = "Refresh Attack Targets",
        Description = "",
        Callback = function()
            MobTypes = GetMobTypes()
            AttackDropdownRef:SetValues(MobTypes)
        end
    })
end)


-- Teleport Tab
local NPCList = {}
local SelectedNPC = ""
local TeleportTween = nil
local IsTeleporting = false
local TeleportDropdownRef = nil
local NoClipConnection = nil

local function GetTeleportLocations()
    local locations = {}
    local proxFolder = Workspace:FindFirstChild("Proximity")
    
    if proxFolder then
        for _, child in ipairs(proxFolder:GetChildren()) do
            if child:IsA("Model") or child:IsA("BasePart") then
                table.insert(locations, child.Name)
            end
        end
    end
    
    table.sort(locations)
    return locations
end

local function GetAllPickaxes()
    local pickaxes = {}
    local proxFolder = Workspace:FindFirstChild("Proximity")
    
    if proxFolder then
        for _, descendant in ipairs(proxFolder:GetDescendants()) do
            if descendant:IsA("Model") or descendant:IsA("BasePart") then
                local name = descendant.Name:lower()
                if name:find("pickaxe") then
                    table.insert(pickaxes, descendant.Name)
                end
            end
        end
    end
    
    if #pickaxes == 0 then
        pickaxes = {"No Pickaxes found"}
    end
    
    table.sort(pickaxes)
    return pickaxes
end

local function GetAllPotions()
    local potions = {}
    local proxFolder = Workspace:FindFirstChild("Proximity")
    
    if proxFolder then
        for _, descendant in ipairs(proxFolder:GetDescendants()) do
            if descendant:IsA("Model") or descendant:IsA("BasePart") then
                local name = descendant.Name:lower()
                if name:find("potion") then
                    table.insert(potions, descendant.Name)
                end
            end
        end
    end
    
    if #potions == 0 then
        potions = {"No Potions found"}
    end
    
    table.sort(potions)
    return potions
end

local function GetAllShops()
    local shops = {}
    local shopsFolder = Workspace:FindFirstChild("Shops")
    
    if shopsFolder then
        for _, child in ipairs(shopsFolder:GetChildren()) do
            if child:IsA("Model") or child:IsA("BasePart") then
                table.insert(shops, child.Name)
            end
        end
    end
    
    if #shops == 0 then
        shops = {"No Shops found"}
    end
    
    table.sort(shops)
    return shops
end

local function GetAllPlayers()
    local players = {}
    
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(players, player.Name)
        end
    end
    
    if #players == 0 then
        players = {"No other players"}
    end
    
    table.sort(players)
    return players
end

local function GetAllNPCs()
    local npcs = {}
    local proxFolder = Workspace:FindFirstChild("Proximity")
    
    if proxFolder then
        for _, descendant in ipairs(proxFolder:GetDescendants()) do
            if descendant:IsA("Model") and descendant:FindFirstChild("Humanoid") then
                table.insert(npcs, descendant.Name)
            end
        end
    end
    
    if #npcs == 0 then
        npcs = {"No NPCs found"}
    end
    
    return npcs
end

local function EnableNoClip(character)
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
    
    NoClipConnection = game:GetService("RunService").Stepped:Connect(function()
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function DisableNoClip(character)
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
    
    if character then
        task.wait(0.1)
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = true
            end
        end
    end
end

local function SafeTweenTeleport(targetCFrame)
    local char = LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local humanoid = char and char:FindFirstChild("Humanoid")
    
    if not root or not humanoid or IsTeleporting then return end
    
    if TeleportTween then
        TeleportTween:Cancel()
        TeleportTween = nil
    end
    
    IsTeleporting = true
    
    local originalAutoRotate = humanoid.AutoRotate
    
    humanoid.AutoRotate = false
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    EnableNoClip(char)
    
    local startPos = root.Position
    local endPos = targetCFrame.Position
    local targetPos = Vector3.new(endPos.X, endPos.Y + 3, endPos.Z)
    local distance = (startPos - targetPos).Magnitude
    
    local tweenTime
    if distance < 50 then
        tweenTime = distance / 80  
    elseif distance < 150 then
        tweenTime = distance / 70  
    elseif distance < 300 then
        tweenTime = distance / 60 
    else
        tweenTime = distance / 50 
    end
    
    local minTime = 0.8
    tweenTime = math.max(minTime, math.min(tweenTime, 10))
    
    local tweenInfo = TweenInfo.new(
        tweenTime,
        Enum.EasingStyle.Linear,  
        Enum.EasingDirection.InOut,  
        0,
        false,
        0
    )
    
    local goal = {CFrame = CFrame.new(targetPos) * (root.CFrame - root.CFrame.Position)}
    TeleportTween = TweenService:Create(root, tweenInfo, goal)
    
    TeleportTween.Completed:Connect(function()
        IsTeleporting = false
        TeleportTween = nil
        
        if humanoid then
            humanoid.AutoRotate = originalAutoRotate
        end
        
        DisableNoClip(char)
    end)
    
    TeleportTween:Play()
end

local function SafeTweenTeleportToNPC(targetCFrame)
    SafeTweenTeleport(targetCFrame)
end

local function Cleanup()
    if TeleportTween then
        TeleportTween:Cancel()
        TeleportTween = nil
    end
    
    if NoClipConnection then
        NoClipConnection:Disconnect()
        NoClipConnection = nil
    end
    
    IsTeleporting = false
    
    local char = LocalPlayer.Character
    if char then
        DisableNoClip(char)
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.AutoRotate = true
        end
    end
end

LocalPlayer.CharacterAdded:Connect(function()
    Cleanup()
end)

task.spawn(function()
    task.wait(1)
    
    NPCList = GetAllNPCs()
    local PickaxeList = GetAllPickaxes()
    local PotionList = GetAllPotions()
    local ShopList = GetAllShops()
    local PlayerList = GetAllPlayers()
    
    TeleportDropdownRef = Tabs.Teleport:AddDropdown("NPCDropdown", {
        Title = "Teleport to NPC",
        Values = NPCList,
        Multi = false,
        Default = SelectedNPC,
        Callback = function(value)
            SelectedNPC = value
            
            local proxFolder = Workspace:FindFirstChild("Proximity")
            if proxFolder then
                for _, descendant in ipairs(proxFolder:GetDescendants()) do
                    if descendant:IsA("Model") and descendant:FindFirstChild("Humanoid") and descendant.Name == value then
                        local char = LocalPlayer.Character
                        local root = char and char:FindFirstChild("HumanoidRootPart")
                        local targetCFrame = descendant.PrimaryPart and descendant.PrimaryPart.CFrame or descendant:GetPivot()
                        
                        if root and targetCFrame then
                            SafeTweenTeleportToNPC(targetCFrame)
                            break
                        end
                    end
                end
            end
        end
    })
    
    Tabs.Teleport:AddDropdown("PickaxeDropdown", {
        Title = "Teleport to Pickaxe",
        Values = PickaxeList,
        Multi = false,
        Default = "",
        Callback = function(value)
            local proxFolder = Workspace:FindFirstChild("Proximity")
            if proxFolder then
                for _, descendant in ipairs(proxFolder:GetDescendants()) do
                    if (descendant:IsA("Model") or descendant:IsA("BasePart")) and descendant.Name == value then
                        local char = LocalPlayer.Character
                        local root = char and char:FindFirstChild("HumanoidRootPart")
                        local targetCFrame = descendant:IsA("Model") and (descendant.PrimaryPart and descendant.PrimaryPart.CFrame or descendant:GetPivot()) or descendant.CFrame
                        
                        if root and targetCFrame then
                            SafeTweenTeleport(targetCFrame)
                            break
                        end
                    end
                end
            end
        end
    })
    
    Tabs.Teleport:AddDropdown("PotionDropdown", {
        Title = "Teleport to Potion",
        Values = PotionList,
        Multi = false,
        Default = "",
        Callback = function(value)
            local proxFolder = Workspace:FindFirstChild("Proximity")
            if proxFolder then
                for _, descendant in ipairs(proxFolder:GetDescendants()) do
                    if (descendant:IsA("Model") or descendant:IsA("BasePart")) and descendant.Name == value then
                        local char = LocalPlayer.Character
                        local root = char and char:FindFirstChild("HumanoidRootPart")
                        local targetCFrame = descendant:IsA("Model") and (descendant.PrimaryPart and descendant.PrimaryPart.CFrame or descendant:GetPivot()) or descendant.CFrame
                        
                        if root and targetCFrame then
                            SafeTweenTeleport(targetCFrame)
                            break
                        end
                    end
                end
            end
        end
    })
    
    Tabs.Teleport:AddDropdown("ShopDropdown", {
        Title = "Teleport to Shop",
        Values = ShopList,
        Multi = false,
        Default = "",
        Callback = function(value)
            local shopsFolder = Workspace:FindFirstChild("Shops")
            if shopsFolder then
                for _, child in ipairs(shopsFolder:GetChildren()) do
                    if (child:IsA("Model") or child:IsA("BasePart")) and child.Name == value then
                        local char = LocalPlayer.Character
                        local root = char and char:FindFirstChild("HumanoidRootPart")
                        local targetCFrame = child:IsA("Model") and (child.PrimaryPart and child.PrimaryPart.CFrame or child:GetPivot()) or child.CFrame
                        
                        if root and targetCFrame then
                            SafeTweenTeleport(targetCFrame)
                            break
                        end
                    end
                end
            end
        end
    })
    
    Tabs.Teleport:AddDropdown("PlayerDropdown", {
        Title = "Teleport to Player",
        Values = PlayerList,
        Multi = false,
        Default = "",
        Callback = function(value)
            local targetPlayer = game:GetService("Players"):FindFirstChild(value)
            if targetPlayer and targetPlayer.Character then
                local char = LocalPlayer.Character
                local root = char and char:FindFirstChild("HumanoidRootPart")
                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                
                if root and targetRoot then
                    SafeTweenTeleport(targetRoot.CFrame)
                end
            end
        end
    })
    
    Tabs.Teleport:AddButton({
        Title = "Refresh All Lists",
        Callback = function()
            NPCList = GetAllNPCs()
            PickaxeList = GetAllPickaxes()
            PotionList = GetAllPotions()
            ShopList = GetAllShops()
            PlayerList = GetAllPlayers()
            TeleportDropdownRef:SetValues(NPCList)
        end
    })
end)

-- ESP Tab
local zombieESPEnabled = false
local playerESPEnabled = false
local npcESPEnabled = false
local rockESPEnabled = false
local selectedRock = "Rock"
local mobESPEnabled = false
local selectedMobESP = "Bomber"
local mobESPColors = {
    Bomber = Color3.fromRGB(255, 100, 100),
    ["Skeleton Rogue"] = Color3.fromRGB(200, 200, 200),
    ["Axe Skeleton"] = Color3.fromRGB(150, 150, 150),
    ["Deathaxe Skeleton"] = Color3.fromRGB(100, 0, 0),
    ["Elite Rogue Skeleton"] = Color3.fromRGB(255, 215, 0),
    ["Elite Deathaxe Skeleton"] = Color3.fromRGB(255, 69, 0),
    Reaper = Color3.fromRGB(0, 0, 0),
    Slime = Color3.fromRGB(0, 255, 0),
    ["Blazing Slime"] = Color3.fromRGB(255, 140, 0)
}
local espConnections = {}
local espObjects = {}

local function clearESP()
    for _, connection in pairs(espConnections) do
        connection:Disconnect()
    end
    espConnections = {}
    
    for _, espObj in pairs(espObjects) do
        if espObj then
            espObj:Destroy()
        end
    end
    espObjects = {}
end

local function createESP(model, color)
    if not model:IsA("Model") or not model:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "ZombieESP"
    billboardGui.Adornee = model:FindFirstChild("HumanoidRootPart")
    billboardGui.Size = UDim2.new(0, 100, 0, 30)
    billboardGui.StudsOffset = Vector3.new(0, 3, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.MaxDistance = 1000
    billboardGui.Parent = model:FindFirstChild("HumanoidRootPart")
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = color or Color3.fromRGB(0, 255, 0)
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextSize = 14
    textLabel.Font = Enum.Font.Arcade
    textLabel.Parent = billboardGui
    
    table.insert(espObjects, billboardGui)
    
    local function updateDistance()
        if (not zombieESPEnabled and not playerESPEnabled and not npcESPEnabled and not rockESPEnabled and not mobESPEnabled) or not model:FindFirstChild("HumanoidRootPart") or not game.Players.LocalPlayer.Character or not game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        local distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - model.HumanoidRootPart.Position).Magnitude
        textLabel.Text = string.format("%s (%.0f)", model.Name, distance)
    end
    
    updateDistance()
    
    local connection = game:GetService("RunService").RenderStepped:Connect(function()
        if zombieESPEnabled or playerESPEnabled or npcESPEnabled or rockESPEnabled or mobESPEnabled then
            updateDistance()
        end
    end)
    
    table.insert(espConnections, connection)
end

local function createRockESP(part, rockName, color)
    if not part:IsA("BasePart") then
        return
    end
    
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "RockESP"
    billboardGui.Adornee = part
    billboardGui.Size = UDim2.new(0, 100, 0, 30)
    billboardGui.StudsOffset = Vector3.new(0, 3, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.MaxDistance = 1000
    billboardGui.Parent = part
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = color or Color3.fromRGB(255, 255, 0)
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextSize = 14
    textLabel.Font = Enum.Font.Arcade
    textLabel.Parent = billboardGui
    
    table.insert(espObjects, billboardGui)
    
    local function updateDistance()
        if not rockESPEnabled or not part or not game.Players.LocalPlayer.Character or not game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        local distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - part.Position).Magnitude
        textLabel.Text = string.format("%s (%.0f)", rockName, distance)
    end
    
    updateDistance()
    
    local connection = game:GetService("RunService").RenderStepped:Connect(function()
        if rockESPEnabled then
            updateDistance()
        end
    end)
    
    table.insert(espConnections, connection)
end

local function setupMobESP()
    if not mobESPEnabled then return end
    
    local livingFolder = workspace:FindFirstChild("Living")
    if not livingFolder then return end
    
    for _, model in pairs(livingFolder:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChild("Humanoid") then
            local cleanName = model.Name:gsub("%d+$", "")
            if cleanName == selectedMobESP then
                local color = mobESPColors[selectedMobESP] or Color3.fromRGB(255, 255, 255)
                createESP(model, color)
            end
        end
    end
    
    local addedConnection = livingFolder.ChildAdded:Connect(function(child)
        if mobESPEnabled and child:IsA("Model") and child:FindFirstChild("Humanoid") then
            task.wait(0.1)
            local cleanName = child.Name:gsub("%d+$", "")
            if cleanName == selectedMobESP then
                local color = mobESPColors[selectedMobESP] or Color3.fromRGB(255, 255, 255)
                createESP(child, color)
            end
        end
    end)
    
    local removedConnection = livingFolder.ChildRemoved:Connect(function(child)
        if child:FindFirstChild("ZombieESP") then
            for i, espObj in pairs(espObjects) do
                if espObj.Parent == child:FindFirstChild("HumanoidRootPart") then
                    espObj:Destroy()
                    table.remove(espObjects, i)
                    break
                end
            end
        end
    end)
    
    table.insert(espConnections, addedConnection)
    table.insert(espConnections, removedConnection)
end

local function setupZombieESP()
    if not zombieESPEnabled then return end
    
    local livingFolder = workspace:FindFirstChild("Living")
    if not livingFolder then return end
    
    for _, model in pairs(livingFolder:GetChildren()) do
        if model:IsA("Model") and string.lower(model.Name):find("zombie") then
            createESP(model, Color3.fromRGB(0, 255, 0))
        end
    end
    
    local addedConnection = livingFolder.ChildAdded:Connect(function(child)
        if zombieESPEnabled and child:IsA("Model") and string.lower(child.Name):find("zombie") then
            task.wait(0.1)
            createESP(child, Color3.fromRGB(0, 255, 0))
        end
    end)
    
    local removedConnection = livingFolder.ChildRemoved:Connect(function(child)
        if child:FindFirstChild("ZombieESP") then
            for i, espObj in pairs(espObjects) do
                if espObj.Parent == child:FindFirstChild("HumanoidRootPart") then
                    espObj:Destroy()
                    table.remove(espObjects, i)
                    break
                end
            end
        end
    end)
    
    table.insert(espConnections, addedConnection)
    table.insert(espConnections, removedConnection)
end

local function setupPlayerESP()
    if not playerESPEnabled then return end
    
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            createESP(player.Character, Color3.fromRGB(0, 150, 255))
        end
    end
    
    local playerAddedConnection = game.Players.PlayerAdded:Connect(function(player)
        if not playerESPEnabled then return end
        
        player.CharacterAdded:Connect(function(character)
            if playerESPEnabled then
                task.wait(0.1)
                createESP(character, Color3.fromRGB(0, 150, 255))
            end
        end)
    end)
    
    local characterAddedConnections = {}
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            local conn = player.CharacterAdded:Connect(function(character)
                if playerESPEnabled then
                    task.wait(0.1)
                    createESP(character, Color3.fromRGB(0, 150, 255))
                end
            end)
            table.insert(characterAddedConnections, conn)
        end
    end
    
    table.insert(espConnections, playerAddedConnection)
    for _, conn in pairs(characterAddedConnections) do
        table.insert(espConnections, conn)
    end
end

local function setupNPCESP()
    if not npcESPEnabled then return end
    
    local proximityFolder = workspace:FindFirstChild("Proximity")
    if not proximityFolder then return end
    
    for _, model in pairs(proximityFolder:GetChildren()) do
        if model:IsA("Model") then
            createESP(model, Color3.fromRGB(255, 0, 0))
        end
    end
    
    local addedConnection = proximityFolder.ChildAdded:Connect(function(child)
        if npcESPEnabled and child:IsA("Model") then
            task.wait(0.1)
            createESP(child, Color3.fromRGB(255, 0, 0))
        end
    end)
    
    local removedConnection = proximityFolder.ChildRemoved:Connect(function(child)
        if child:FindFirstChild("ZombieESP") then
            for i, espObj in pairs(espObjects) do
                if espObj.Parent == child:FindFirstChild("HumanoidRootPart") then
                    espObj:Destroy()
                    table.remove(espObjects, i)
                    break
                end
            end
        end
    end)
    
    table.insert(espConnections, addedConnection)
    table.insert(espConnections, removedConnection)
end

local function setupRockESP()
    if not rockESPEnabled then return end
    
    local rocksFolder = workspace:FindFirstChild("Rocks")
    if not rocksFolder then return end
    
    local function scanFolder(folder)
        for _, item in pairs(folder:GetDescendants()) do
            if item.Name == "SpawnLocation" and item:IsA("BasePart") then
                for _, child in pairs(item:GetChildren()) do
                    if child:IsA("Model") and child.Name == selectedRock then
                        createRockESP(item, selectedRock, Color3.fromRGB(255, 255, 0))
                        break
                    end
                end
            end
        end
    end
    
    scanFolder(rocksFolder)
    
    local function handleRockSpawn(spawnLocation)
        if not rockESPEnabled or not spawnLocation:IsA("BasePart") or spawnLocation.Name ~= "SpawnLocation" then
            return
        end
        
        local connection
        connection = spawnLocation.ChildAdded:Connect(function(child)
            if rockESPEnabled and child:IsA("Model") and child.Name == selectedRock then
                task.wait(0.1)
                createRockESP(spawnLocation, selectedRock, Color3.fromRGB(255, 255, 0))
            end
        end)
        table.insert(espConnections, connection)
    end
    
    for _, folder in pairs(rocksFolder:GetDescendants()) do
        if folder.Name == "SpawnLocation" and folder:IsA("BasePart") then
            handleRockSpawn(folder)
        end
    end
    
    local descendantAddedConnection = rocksFolder.DescendantAdded:Connect(function(descendant)
        if rockESPEnabled and descendant.Name == "SpawnLocation" and descendant:IsA("BasePart") then
            handleRockSpawn(descendant)
        end
    end)
    
    table.insert(espConnections, descendantAddedConnection)
end

Tabs.Esp:AddSection("Rock ESP")

Tabs.Esp:AddDropdown("RockDropdown", {
    Title = "Select Rock Type",
    Description = "",
    Values = {"Rock", "Pebble", "Boulder", "Lucky Block", "Basalt", "Lava Rock", "Basalt Rock", "Basalt Core", "Volcanic Rock", "Cyan Crystal", "Voilet Crystal", "Crimson Crystal", "Light Crystal", "Earth Crystal", "Basalt Vein"},
    Multi = false,
    Default = 1,
    Callback = function(value)
        selectedRock = value
        if rockESPEnabled then
            clearESP()
            setupRockESP()
            if zombieESPEnabled then setupZombieESP() end
            if playerESPEnabled then setupPlayerESP() end
            if npcESPEnabled then setupNPCESP() end
            if mobESPEnabled then setupMobESP() end
        end
    end
})

Tabs.Esp:AddToggle("RockESP", {
    Title = "Rock ESP", 
    Description = "",
    Default = false,
    Callback = function(state)
        rockESPEnabled = state
        clearESP()
        if state then setupRockESP() end
        if zombieESPEnabled then setupZombieESP() end
        if playerESPEnabled then setupPlayerESP() end
        if npcESPEnabled then setupNPCESP() end
        if mobESPEnabled then setupMobESP() end
    end 
})

Tabs.Esp:AddSection("Mob ESP")

Tabs.Esp:AddDropdown("MobESPDropdown", {
    Title = "Select Mob Type",
    Description = "",
    Values = {"Bomber", "Skeleton Rogue", "Axe Skeleton", "Deathaxe Skeleton", "Elite Rogue Skeleton", "Elite Deathaxe Skeleton", "Reaper", "Slime", "Blazing Slime"},
    Multi = false,
    Default = "Bomber",
    Callback = function(value)
        selectedMobESP = value
        if mobESPEnabled then
            clearESP()
            setupMobESP()
            if zombieESPEnabled then setupZombieESP() end
            if playerESPEnabled then setupPlayerESP() end
            if npcESPEnabled then setupNPCESP() end
            if rockESPEnabled then setupRockESP() end
        end
    end
})

Tabs.Esp:AddToggle("MobESP", {
    Title = "Mob ESP", 
    Description = "",
    Default = false,
    Callback = function(state)
        mobESPEnabled = state
        clearESP()
        if state then setupMobESP() end
        if zombieESPEnabled then setupZombieESP() end
        if playerESPEnabled then setupPlayerESP() end
        if npcESPEnabled then setupNPCESP() end
        if rockESPEnabled then setupRockESP() end
    end 
})

Tabs.Esp:AddSection("Other ESP")

Tabs.Esp:AddToggle("MyToggle", {
    Title = "Living Zombie ESP", 
    Description = "",
    Default = false,
    Callback = function(state)
        zombieESPEnabled = state
        clearESP()
        if state then setupZombieESP() end
        if playerESPEnabled then setupPlayerESP() end
        if npcESPEnabled then setupNPCESP() end
        if rockESPEnabled then setupRockESP() end
        if mobESPEnabled then setupMobESP() end
    end 
})

Tabs.Esp:AddToggle("PlayerESP", {
    Title = "Player ESP", 
    Description = "",
    Default = false,
    Callback = function(state)
        playerESPEnabled = state
        clearESP()
        if state then setupPlayerESP() end
        if zombieESPEnabled then setupZombieESP() end
        if npcESPEnabled then setupNPCESP() end
        if rockESPEnabled then setupRockESP() end
        if mobESPEnabled then setupMobESP() end
    end 
})

Tabs.Esp:AddToggle("NPCESP", {
    Title = "NPC ESP", 
    Description = "",
    Default = false,
    Callback = function(state)
        npcESPEnabled = state
        clearESP()
        if state then setupNPCESP() end
        if zombieESPEnabled then setupZombieESP() end
        if playerESPEnabled then setupPlayerESP() end
        if rockESPEnabled then setupRockESP() end
        if mobESPEnabled then setupMobESP() end
    end 
})

-- Sell Tab

local selectedOres = {}
local selectedMaterials = {}
local autoSellOresEnabled = false
local autoSellMaterialsEnabled = false
local npcTargetOres = nil
local npcTargetMaterials = nil
local dialogueInitializedOres = false
local dialogueInitializedMaterials = false
local OreDropdown = nil
local MaterialDropdown = nil

local function GetAllOreItems()
    local items = {}
    local assets = ReplicatedStorage:FindFirstChild("Assets")
    if not assets then return items end
    
    local ores = assets:FindFirstChild("Ores")
    if not ores then return items end
    
    for _, item in ipairs(ores:GetChildren()) do
        if item:IsA("Model") then
            table.insert(items, item.Name)
        end
    end
    table.sort(items)
    return items
end

local function GetAllMaterialItems()
    local items = {}
    
    local assets = ReplicatedStorage:FindFirstChild("Assets")
    if assets then
        local materials = assets:FindFirstChild("Materials")
        if materials then
            for _, item in ipairs(materials:GetChildren()) do
                if item:IsA("Model") then
                    local lowerName = item.Name:lower()
                    if lowerName:find("essence") then
                        table.insert(items, item.Name)
                    end
                end
            end
        end
    end
    
    local player = Players.LocalPlayer
    local playerGui = player and player:FindFirstChild("PlayerGui")
    if playerGui then
        local menu = playerGui:FindFirstChild("Menu")
        if menu then
            local stash = menu:FindFirstChild("Frame") 
                and menu.Frame:FindFirstChild("Frame")
                and menu.Frame.Frame:FindFirstChild("Menus")
                and menu.Frame.Frame.Menus:FindFirstChild("Stash")
                and menu.Frame.Frame.Menus.Stash:FindFirstChild("Background")
            
            if stash then
                for _, itemFrame in ipairs(stash:GetChildren()) do
                    local lowerName = itemFrame.Name:lower()
                    if lowerName:find("essence") then
                        local alreadyExists = false
                        for _, existingItem in ipairs(items) do
                            if existingItem:lower() == itemFrame.Name:lower() then
                                alreadyExists = true
                                break
                            end
                        end
                        
                        if not alreadyExists then
                            table.insert(items, itemFrame.Name)
                        end
                    end
                end
            end
        end
    end
    
    table.sort(items)
    return items
end

local function GetItemQuantity(itemName)
    local player = Players.LocalPlayer
    local playerGui = player and player:FindFirstChild("PlayerGui")
    if not playerGui then return 0 end
    
    local menu = playerGui:FindFirstChild("Menu")
    if not menu then return 0 end
    
    local stash = menu:FindFirstChild("Frame") 
        and menu.Frame:FindFirstChild("Frame")
        and menu.Frame.Frame:FindFirstChild("Menus")
        and menu.Frame.Frame.Menus:FindFirstChild("Stash")
        and menu.Frame.Frame.Menus.Stash:FindFirstChild("Background")
    
    if not stash then return 0 end
    
    local itemFrame = stash:FindFirstChild(itemName)
    
    if not itemFrame then
        for _, child in ipairs(stash:GetChildren()) do
            if child.Name:lower() == itemName:lower() then
                itemFrame = child
                break
            end
        end
    end
    
    if not itemFrame then return 0 end
    
    local quantityLabel = itemFrame:FindFirstChild("Main") 
        and itemFrame.Main:FindFirstChild("Quantity")
    
    if quantityLabel and quantityLabel:IsA("TextLabel") then
        local quantityText = quantityLabel.Text:gsub("[^%d]", "")
        return tonumber(quantityText) or 0
    end
    
    local quantityTextLabel = itemFrame:FindFirstChild("Quantity")
    if quantityTextLabel and quantityTextLabel:IsA("TextLabel") then
        local quantityText = quantityTextLabel.Text:gsub("[^%d]", "")
        return tonumber(quantityText) or 0
    end
    
    return 0
end

local function FormatOreDropdownOptions()
    local allItems = GetAllOreItems()
    local formatted = {}
    for _, itemName in ipairs(allItems) do
        local quantity = GetItemQuantity(itemName)
        if quantity > 0 then
            table.insert(formatted, itemName .. " (" .. tostring(quantity) .. ")")
        end
    end
    return formatted
end

local function FormatMaterialDropdownOptions()
    local allItems = GetAllMaterialItems()
    local formatted = {}
    for _, itemName in ipairs(allItems) do
        local quantity = GetItemQuantity(itemName)
        if quantity > 0 then
            table.insert(formatted, itemName .. " (" .. tostring(quantity) .. ")")
        else
            table.insert(formatted, itemName)
        end
    end
    return formatted
end

task.spawn(function()
    local dialogueService = ReplicatedStorage:WaitForChild("Shared")
        :WaitForChild("Packages")
        :WaitForChild("Knit")
        :WaitForChild("Services")
        :WaitForChild("DialogueService")
        :WaitForChild("RF")
        :WaitForChild("RunCommand")
    
    local proximityService = ReplicatedStorage:WaitForChild("Shared")
        :WaitForChild("Packages")
        :WaitForChild("Knit")
        :WaitForChild("Services")
        :WaitForChild("ProximityService")
        :WaitForChild("RF")
        :WaitForChild("ForceDialogue")
    
    while true do
        if autoSellOresEnabled and #selectedOres > 0 then
            if not npcTargetOres then
                local proximity = workspace:FindFirstChild("Proximity")
                npcTargetOres = proximity and proximity:FindFirstChild("Greedy Cey")
            end
            
            if npcTargetOres and not dialogueInitializedOres then
                pcall(function()
                    proximityService:InvokeServer(npcTargetOres, "SellConfirmMisc")
                end)
                dialogueInitializedOres = true
            end
            
            if npcTargetOres and dialogueInitializedOres then
                local basket = {}
                local hasItems = false
                
                for _, itemName in ipairs(selectedOres) do
                    local quantity = GetItemQuantity(itemName)
                    if quantity > 0 then
                        basket[itemName] = quantity
                        hasItems = true
                    end
                end
                
                if hasItems then
                    pcall(function()
                        dialogueService:InvokeServer("SellConfirm", {Basket = basket})
                    end)
                    
                    task.wait(0.1)
                    
                    if OreDropdown then
                        local newOptions = FormatOreDropdownOptions()
                        OreDropdown:SetValues(newOptions)
                    end
                    
                    local remainingOres = {}
                    for _, itemName in ipairs(selectedOres) do
                        if GetItemQuantity(itemName) > 0 then
                            table.insert(remainingOres, itemName)
                        end
                    end
                    selectedOres = remainingOres
                    
                    if #selectedOres == 0 then
                        autoSellOresEnabled = false
                    end
                end
            end
        else
            npcTargetOres = nil
            dialogueInitializedOres = false
        end
        task.wait(0.05)
    end
end)

task.spawn(function()
    local dialogueService = ReplicatedStorage:WaitForChild("Shared")
        :WaitForChild("Packages")
        :WaitForChild("Knit")
        :WaitForChild("Services")
        :WaitForChild("DialogueService")
        :WaitForChild("RF")
        :WaitForChild("RunCommand")
    
    local proximityService = ReplicatedStorage:WaitForChild("Shared")
        :WaitForChild("Packages")
        :WaitForChild("Knit")
        :WaitForChild("Services")
        :WaitForChild("ProximityService")
        :WaitForChild("RF")
        :WaitForChild("ForceDialogue")
    
    while true do
        if autoSellMaterialsEnabled and #selectedMaterials > 0 then
            if not npcTargetMaterials then
                local proximity = workspace:FindFirstChild("Proximity")
                npcTargetMaterials = proximity and proximity:FindFirstChild("Greedy Cey")
            end
            
            if npcTargetMaterials and not dialogueInitializedMaterials then
                pcall(function()
                    proximityService:InvokeServer(npcTargetMaterials, "SellConfirmMisc")
                end)
                dialogueInitializedMaterials = true
            end
            
            if npcTargetMaterials and dialogueInitializedMaterials then
                local basket = {}
                local hasItems = false
                
                for _, itemName in ipairs(selectedMaterials) do
                    local quantity = GetItemQuantity(itemName)
                    if quantity > 0 then
                        basket[itemName] = quantity
                        hasItems = true
                    end
                end
                
                if hasItems then
                    pcall(function()
                        dialogueService:InvokeServer("SellConfirm", {Basket = basket})
                    end)
                    
                    task.wait(0.1)
                    
                    if MaterialDropdown then
                        local newOptions = FormatMaterialDropdownOptions()
                        MaterialDropdown:SetValues(newOptions)
                    end
                    
                    local remainingMaterials = {}
                    for _, itemName in ipairs(selectedMaterials) do
                        if GetItemQuantity(itemName) > 0 then
                            table.insert(remainingMaterials, itemName)
                        end
                    end
                    selectedMaterials = remainingMaterials
                    
                    if #selectedMaterials == 0 then
                        autoSellMaterialsEnabled = false
                    end
                end
            end
        else
            npcTargetMaterials = nil
            dialogueInitializedMaterials = false
        end
        task.wait(0.05)
    end
end)

task.spawn(function()
    while true do
        task.wait(2)
        if autoSellOresEnabled then
            if OreDropdown then
                local newOptions = FormatOreDropdownOptions()
                OreDropdown:SetValues(newOptions)
                
                if #selectedOres > 0 then
                    local remainingOres = {}
                    for _, itemName in ipairs(selectedOres) do
                        if GetItemQuantity(itemName) > 0 then
                            table.insert(remainingOres, itemName)
                        end
                    end
                    selectedOres = remainingOres
                end
            end
            
            if #selectedOres == 0 then
                autoSellOresEnabled = false
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait(2)
        if autoSellMaterialsEnabled then
            if MaterialDropdown then
                local newOptions = FormatMaterialDropdownOptions()
                MaterialDropdown:SetValues(newOptions)
                
                if #selectedMaterials > 0 then
                    local remainingMaterials = {}
                    for _, itemName in ipairs(selectedMaterials) do
                        if GetItemQuantity(itemName) > 0 then
                            table.insert(remainingMaterials, itemName)
                        end
                    end
                    selectedMaterials = remainingMaterials
                end
            end
            
            if #selectedMaterials == 0 then
                autoSellMaterialsEnabled = false
            end
        end
    end
end)

Tabs.Sell:AddParagraph({
    Title = "Important !",
    Content = "Dont Do Auto Sell + Auto Mining At The Same Time Game Will Kick You"
})

Tabs.Sell:AddSection("Sell Ores")


OreDropdown = Tabs.Sell:AddDropdown("SellOreDropdown", {
    Title = "Select Ores",
    Description = "",
    Values = FormatOreDropdownOptions(),
    Multi = true,
    Default = {},
})

OreDropdown:OnChanged(function(selected)
    selectedOres = {}
    if typeof(selected) == "table" then
        for itemKey, isSelected in pairs(selected) do
            if isSelected then
                local cleanName = itemKey:gsub("%s*%(%d+%)", "")
                table.insert(selectedOres, cleanName)
            end
        end
    end
end)

Tabs.Sell:AddToggle("AutoSellOresToggle", {
    Title = "Auto Sell Ores", 
    Description = "",
    Default = false,
    Callback = function(state)
        autoSellOresEnabled = state
        if state and #selectedOres == 0 then
            autoSellOresEnabled = false
        end
    end 
})

Tabs.Sell:AddButton({
    Title = "Refresh Ore List",
    Description = "",
    Callback = function()
        local newOreOptions = FormatOreDropdownOptions()
        OreDropdown:SetValues(newOreOptions)
    end
})

Tabs.Sell:AddSection("Sell Essence Materials")

MaterialDropdown = Tabs.Sell:AddDropdown("SellMaterialDropdown", {
    Title = "Select Essence Materials",
    Description = "",
    Values = FormatMaterialDropdownOptions(),
    Multi = true,
    Default = {},
})

MaterialDropdown:OnChanged(function(selected)
    selectedMaterials = {}
    if typeof(selected) == "table" then
        for itemKey, isSelected in pairs(selected) do
            if isSelected then
                local cleanName = itemKey:gsub("%s*%(%d+%)", "")
                table.insert(selectedMaterials, cleanName)
            end
        end
    end
end)

Tabs.Sell:AddToggle("AutoSellMaterialsToggle", {
    Title = "Auto Sell ", 
    Description = "",
    Default = false,
    Callback = function(state)
        autoSellMaterialsEnabled = state
        if state and #selectedMaterials == 0 then
            autoSellMaterialsEnabled = false
        end
    end 
})

Tabs.Sell:AddButton({
    Title = "Refresh Essence List",
    Description = "",
    Callback = function()
        local newMaterialOptions = FormatMaterialDropdownOptions()
        MaterialDropdown:SetValues(newMaterialOptions)
    end
})
-- Auto Roll Tab

local selectedRace = "Human"
local isRerolling = false
local player = game.Players.LocalPlayer
local rerollThread = nil
local checkThread = nil

local function stopAllLoops()
    isRerolling = false
    
    if rerollThread and coroutine.status(rerollThread) ~= "dead" then
        coroutine.close(rerollThread)
    end
    rerollThread = nil
    
    if checkThread and coroutine.status(checkThread) ~= "dead" then
        coroutine.close(checkThread)
    end
    checkThread = nil
end

local function getCurrentRace()
    if not player then return nil end
    
    local character = player.Character
    if not character then return nil end
    
    local livingFolder = workspace:FindFirstChild("Living")
    if not livingFolder then return nil end
    
    local playerModel = livingFolder:FindFirstChild(player.Name)
    if not playerModel then return nil end
    
    local raceFolder = playerModel:FindFirstChild("RaceFolder")
    if not raceFolder then return nil end
    
    for _, child in ipairs(raceFolder:GetChildren()) do
        if child:IsA("Model") then
            return child.Name
        end
    end
    
    return nil
end

local function performReroll()
    local raceService = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages")
        :WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("RaceService")
        :WaitForChild("RF"):WaitForChild("Reroll")
    
    local success = pcall(function()
        raceService:InvokeServer()
        return true
    end)
    
    return success
end


local function rerollLoop()
    while isRerolling do
        local currentRace = getCurrentRace()
        
        if currentRace and currentRace == selectedRace then
            stopAllLoops()
            if AutoRerollToggle then
                AutoRerollToggle:SetState(false)
            end
            updateRaceStatusParagraph()
            break
        end
        
        local rerollSuccess = performReroll()
        
        if not rerollSuccess then
            stopAllLoops()
            if AutoRerollToggle then
                AutoRerollToggle:SetState(false)
            end
            updateRaceStatusParagraph()
            break
        end
        
        task.wait(0.5)
    end
end

local function checkLoop()
    while isRerolling do
        updateRaceStatusParagraph()
        task.wait(0.1)
    end
end

Tabs.Sell:AddSection("Auto Roll Races")

local raceStatusParagraph = Tabs.Sell:AddParagraph({
    Title = "Target: " .. selectedRace .. " | Current: None"
})

local function updateRaceStatusParagraph()
    local currentRace = getCurrentRace() or "None"
    raceStatusParagraph:SetTitle("Target: " .. selectedRace .. " | Current: " .. currentRace)
    return currentRace
end


Tabs.Sell:AddDropdown("RaceDropdown", {
    Title = "Select Race",
    Values = {"Human", "Elf", "Zombie", "Goblin", "Undead", "Orc", "Dwarf", "Shadow", "Minotaur", "Dragonborn", "Golem", "Angel", "Demon"},
    Multi = false,
    Default = 1,
    Callback = function(value)
        selectedRace = value
        updateRaceStatusParagraph()
    end
})

local AutoRerollToggle = Tabs.Sell:AddToggle("AutoRerollToggle", {
    Title = "Auto Reroll Race", 
    Default = false,
    Callback = function(state)
        if state then
            isRerolling = true
            rerollThread = coroutine.create(rerollLoop)
            checkThread = coroutine.create(checkLoop)
            coroutine.resume(rerollThread)
            coroutine.resume(checkThread)
        else
            stopAllLoops()
            updateRaceStatusParagraph()
        end
    end 
})

Tabs.Sell:AddButton({
    Title = "Manual Reroll",
    Callback = function()
        performReroll()
        task.wait(0.2)
        updateRaceStatusParagraph()
    end
})



-- Player Tab 


Tabs.Player:AddToggle("MyToggle", {
    Title = "See Through Walls", 
    Description = "",
    Default = false,
    Callback = function(state)
        if not game:IsLoaded() then
            game.Loaded:Wait()
        end

        local PopperClient = game:GetService("Players").LocalPlayer:WaitForChild("PlayerScripts").PlayerModule.CameraModule.ZoomController.Popper

        task.wait(0.5)

        for i, v in next, getgc(true) do
            if type(v) == "function" then
                local success, env = pcall(function()
                    return getfenv(v)
                end)
                
                if success and env and env.script == PopperClient then
                    for i2, v2 in pairs(debug.getconstants(v)) do
                        if type(v2) == "number" then
                            if state then
                                if v2 == 0.25 then
                                    debug.setconstant(v, i2, 0)
                                end
                            else
                                if v2 == 0 then
                                    debug.setconstant(v, i2, 0.25)
                                end
                            end
                        end
                    end
                end
            end
        end
    end 
})


Tabs.Player:AddButton({
    Title = "Anti AFK",
    Callback = function()
        pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/hassanxzayn-lua/Anti-afk/main/antiafkbyhassanxzyn"))()
        end)
    end
})



local RS = game:GetService("ReplicatedStorage")
local RunRF = RS.Shared.Packages.Knit.Services.CharacterService.RF.Run
local running = false

task.spawn(function()
    while true do
        task.wait(0.1) 
        if running then
            RunRF:InvokeServer()
        end
    end
end)

Tabs.Player:AddToggle("MyToggle", {
    Title = "Auto Run",
    Default = false,
    Callback = function(value)
        running = value
    end
})



local savedSpeed = 50

local function setupFlySystem()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local HRP = character:WaitForChild("HumanoidRootPart")
    local Camera = workspace.CurrentCamera

    local baseSpeed = savedSpeed
    local flySpeed = baseSpeed
    local flying = false
    local forwardHold = 0
    local inputFlags = { forward = false, back = false, left = false, right = false, up = false, down = false }

    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)

    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)

    local function newAnim(id)
        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://" .. id
        return anim
    end

    local animations = {
        forward = newAnim(90872539),
        up = newAnim(90872539),
        right1 = newAnim(136801964),
        right2 = newAnim(142495255),
        left1 = newAnim(136801964),
        left2 = newAnim(142495255),
        flyLow1 = newAnim(97169019),
        flyLow2 = newAnim(282574440),
        flyFast = newAnim(282574440),
        back1 = newAnim(136801964),
        back2 = newAnim(106772613),
        back3 = newAnim(42070810),
        back4 = newAnim(214744412),
        down = newAnim(233322916),
        idle1 = newAnim(97171309)
    }

    local tracks = {}
    for name, anim in pairs(animations) do
        tracks[name] = humanoid:LoadAnimation(anim)
    end

    local function stopAll()
        for _, track in pairs(tracks) do
            track:Stop()
        end
    end

    local function startFlying()
        flying = true
        forwardHold = 0
        flySpeed = baseSpeed
        bodyVelocity.Parent = HRP
        bodyGyro.Parent = HRP
        humanoid.PlatformStand = true
    end

    local function stopFlying()
        flying = false
        bodyVelocity.Parent = nil
        bodyGyro.Parent = nil
        humanoid.PlatformStand = false
        stopAll()
    end

    player.CharacterAdded:Connect(function(newCharacter)
        character = newCharacter
        humanoid = character:WaitForChild("Humanoid")
        HRP = character:WaitForChild("HumanoidRootPart")
        
        tracks = {}
        for name, anim in pairs(animations) do
            tracks[name] = humanoid:LoadAnimation(anim)
        end
        
        if flying then
            startFlying()
        end
    end)

    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.W then inputFlags.forward = true end
        if input.KeyCode == Enum.KeyCode.S then inputFlags.back = true end
        if input.KeyCode == Enum.KeyCode.A then inputFlags.left = true end
        if input.KeyCode == Enum.KeyCode.D then inputFlags.right = true end
        if input.KeyCode == Enum.KeyCode.E then inputFlags.up = true end
        if input.KeyCode == Enum.KeyCode.Q then inputFlags.down = true end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.W then inputFlags.forward = false end
        if input.KeyCode == Enum.KeyCode.S then inputFlags.back = false end
        if input.KeyCode == Enum.KeyCode.A then inputFlags.left = false end
        if input.KeyCode == Enum.KeyCode.D then inputFlags.right = false end
        if input.KeyCode == Enum.KeyCode.E then inputFlags.up = false end
        if input.KeyCode == Enum.KeyCode.Q then inputFlags.down = false end
    end)

    local renderConnection
    renderConnection = RunService.RenderStepped:Connect(function(dt)
        if not flying then return end

        if not inputFlags.forward then forwardHold = 0 end

        local dir = Vector3.zero
        local camCF = Camera.CFrame

        if inputFlags.forward then dir += camCF.LookVector end
        if inputFlags.back then dir -= camCF.LookVector end
        if inputFlags.left then dir -= camCF.RightVector end
        if inputFlags.right then dir += camCF.RightVector end
        if inputFlags.up then dir += Vector3.yAxis end
        if inputFlags.down then dir -= Vector3.yAxis end

        if dir.Magnitude > 0 then dir = dir.Unit end

        bodyVelocity.Velocity = dir * flySpeed
        bodyGyro.CFrame = camCF

        if inputFlags.up then
            if not tracks.up.IsPlaying then stopAll(); tracks.up:Play() end
        elseif inputFlags.down then
            if not tracks.down.IsPlaying then stopAll(); tracks.down:Play() end
        elseif inputFlags.left then
            if not tracks.left1.IsPlaying then
                stopAll()
                tracks.left1:Play(); tracks.left1.TimePosition = 2.0; tracks.left1:AdjustSpeed(0)
                tracks.left2:Play(); tracks.left2.TimePosition = 0.5; tracks.left2:AdjustSpeed(0)
            end
        elseif inputFlags.right then
            if not tracks.right1.IsPlaying then
                stopAll()
                tracks.right1:Play(); tracks.right1.TimePosition = 1.1; tracks.right1:AdjustSpeed(0)
                tracks.right2:Play(); tracks.right2.TimePosition = 0.5; tracks.right2:AdjustSpeed(0)
            end
        elseif inputFlags.back then
            if not tracks.back1.IsPlaying then
                stopAll()
                tracks.back1:Play(); tracks.back1.TimePosition = 5.3; tracks.back1:AdjustSpeed(0)
                tracks.back2:Play(); tracks.back2:AdjustSpeed(0)
                tracks.back3:Play(); tracks.back3.TimePosition = 0.8; tracks.back3:AdjustSpeed(0)
                tracks.back4:Play(); tracks.back4.TimePosition = 1; tracks.back4:AdjustSpeed(0)
            end
        elseif inputFlags.forward then
            forwardHold += dt
            if forwardHold >= 3 then
                if not tracks.flyFast.IsPlaying then
                    stopAll()
                    flySpeed = baseSpeed * 1.3
                    tracks.flyFast:Play(); tracks.flyFast:AdjustSpeed(0.05)
                end
            else
                if not tracks.flyLow1.IsPlaying then
                    stopAll()
                    flySpeed = baseSpeed
                    tracks.flyLow1:Play()
                    tracks.flyLow2:Play()
                end
            end
        else
            if not tracks.idle1.IsPlaying then
                stopAll()
                tracks.idle1:Play(); tracks.idle1:AdjustSpeed(0)
            end
        end
    end)

    return {
        toggle = function(state)
            if state then
                startFlying()
            else
                stopFlying()
            end
        end,
        updateSpeed = function(speed)
            baseSpeed = speed
            savedSpeed = speed
            if flying then flySpeed = baseSpeed end
        end
    }
end

local flySystem = setupFlySystem()

Tabs.Player:AddToggle("MyToggle", 
{
    Title = "Fly", 
    Description = "",
    Default = false,
    Callback = function(Value)
        flySystem.toggle(Value)
    end 
})

Tabs.Player:AddSlider("FlySpeed", 
{
    Title = "Fly Speed",
    Description = "",
    Default = savedSpeed,
    Min = 10,
    Max = 150,
    Rounding = 0,
    Callback = function(Value)
        flySystem.updateSpeed(Value)
    end
})





-- Forge


Tabs.Forge:AddSection("Auto Forge")


Tabs.Forge:AddButton({
    Title = "Open Forge",
    Description = "",
    Callback = function()
fireproximityprompt(workspace.Proximity.Forge.ProximityPrompt)
    end
})

local instantForgeEnabled = false

local function setupInstantForge()
    repeat task.wait() until ReplicatedStorage:FindFirstChild("Controllers")
    repeat task.wait() until ReplicatedStorage.Controllers:FindFirstChild("ForgeController")
   
    local ForgeControllerModule = ReplicatedStorage.Controllers.ForgeController
    local ForgeController = require(ForgeControllerModule)
   
    local originalMinigames = {}
   
    local function wrapMinigame(minigameName)
        task.spawn(function()
            repeat task.wait() until ForgeController.Minigames
           
            local minigameModule = ForgeController.Minigames[minigameName]
            if minigameModule and minigameModule.Start then
                originalMinigames[minigameName] = minigameModule.Start
               
                minigameModule.Start = function(self, data)
                    if instantForgeEnabled then
                        if minigameName == "MeltMinigame" then
                            return 0.01, true
                        elseif minigameName == "PourMinigame" then
                            return 0.01
                        elseif minigameName == "HammerMinigame" then
                            local result1, result2, result3
                            local originalCompleted = false
                            
                            task.spawn(function()
                                result1, result2, result3 = originalMinigames[minigameName](self, data)
                                originalCompleted = true
                            end)
                            
                            task.wait(2)
                            
                            local foundMold = false
                            local attempts = 0
                            
                            while not foundMold and attempts < 150 do
                                attempts = attempts + 1
                                
                                for _, obj in pairs(workspace.Debris:GetDescendants()) do
                                    if obj:IsA("ClickDetector") and obj.Parent and obj.Parent:IsA("Model") then
                                        local parentModel = obj.Parent
                                        
                                        if parentModel:FindFirstChild("bar") or parentModel.Name:lower():find("mold") then
                                            for i = 1, 3 do
                                                fireclickdetector(obj)
                                                task.wait(0.08)
                                            end
                                            
                                            foundMold = true
                                            break
                                        end
                                    end
                                end
                                
                                task.wait(0.03)
                            end
                            
                            while not originalCompleted do
                                task.wait(0.1)
                            end
                            
                            return result1, result2, result3
                        end
                    else
                        return originalMinigames[minigameName](self, data)
                    end
                end
            end
        end)
    end
   
    task.wait(1)
   
    wrapMinigame("MeltMinigame")
    wrapMinigame("PourMinigame")
    wrapMinigame("HammerMinigame")
end

task.spawn(setupInstantForge)

Tabs.Forge:AddToggle("InstantForgeToggle", {
    Title = "Auto Forge",
    Description = "",
    Default = false,
    Callback = function(state)
        instantForgeEnabled = state
    end
})

Tabs.Forge:AddParagraph({
    Title = "Auto Forge | Info",
    Content = "It Gonna Auto Melt/Auto Pour/Auto Mold - 100% Perfectly"
})


-- Auto Potion Tab

local SelectedPotion = ""
local AutoPotionEnabled = false
local PotionInterval = 2
local AutoPotionConnection = nil
local NextUseTime = 0

local function getPotionNames()
    local potionNames = {}
    local potionFolder = game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Extras"):WaitForChild("Potion")
    
    for _, potion in ipairs(potionFolder:GetChildren()) do
        if potion:IsA("Model") then
            table.insert(potionNames, potion.Name)
        end
    end
    
    return potionNames
end

local function usePotion()
    local args = {SelectedPotion}
    local success, err = pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated"):InvokeServer(unpack(args))
    end)
    
    if success then
        NextUseTime = tick() + PotionInterval
    end
end

local function stopAutoPotion()
    if AutoPotionConnection then
        AutoPotionConnection:Disconnect()
        AutoPotionConnection = nil
    end
    NextUseTime = 0
end

Tabs.Forge:AddSection("Auto Use Potions")

local availablePotions = getPotionNames()

local Dropdown = Tabs.Forge:AddDropdown("PotionDropdown", {
    Title = "Select Potion",
    Description = "",
    Values = availablePotions,
    Multi = false,
    Default = availablePotions[1] or "none",
})

Dropdown:OnChanged(function(value)
    SelectedPotion = value
end)

local Slider = Tabs.Forge:AddSlider("PotionInterval", {
    Title = "Potion Interval (s)",
    Description = "",
    Default = 2,
    Min = 5,
    Max = 600,
    Rounding = 0,
})

Slider:OnChanged(function(value)
    PotionInterval = value
end)

local Toggle = Tabs.Forge:AddToggle("AutoPotionToggle", {
    Title = "Auto Use Potion",
    Description = "",
    Default = false,
})

Toggle:OnChanged(function(state)
    AutoPotionEnabled = state
    if state then
        stopAutoPotion()
        NextUseTime = tick() + PotionInterval
        AutoPotionConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if not AutoPotionEnabled then
                stopAutoPotion()
                return
            end
            if tick() >= NextUseTime then
                usePotion()
            end
        end)
    else
        stopAutoPotion()
    end
end)

--envirnomnet


-- Background tasks
task.spawn(function()
    while true do
        RockTypes = GetRockTypes()
        MobTypes = GetMobTypes()
        TeleportLocations = GetTeleportLocations()
        task.wait(5)
    end
end)
